<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type='text/xsl' href='lib/rfc2629.xslt' ?>

<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc linkmailto="no"?>
<?rfc editing="no"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc-ext allow-markup-in-artwork="yes" ?>
<?rfc-ext include-index="no" ?>

<rfc category="std"
    ipr="trust200902"
    docName="draft-ietf-httpbis-header-compression-latest"
    x:maturity-level="proposed"
    xmlns:x="http://purl.org/net/xml2rfc/ext">
    <x:feedback template="mailto:ietf-http-wg@w3.org?subject={docname},%20%22{section}%22&amp;body=&lt;{ref}&gt;:"/>
    <front>
        <title abbrev="HPACK">HPACK - HTTP/2 のためのヘッダ圧縮</title>

        <author initials="R." surname="Peon" fullname="Roberto Peon">
            <organization>Google, Inc</organization>
            <address>
                <email>fenix@google.com</email>
            </address>
        </author>

        <author initials="H." surname="Ruellan" fullname="Hervé Ruellan">
            <organization>Canon CRF</organization>
            <address>
                <email>herve.ruellan@crf.canon.fr</email>
            </address>
        </author>

        <date year="2014"/>
        <area>Applications</area>
        <workgroup>HTTPbis</workgroup>
        <keyword>HTTP</keyword>
        <keyword>Header</keyword>
        <abstract>
            <t>
                この仕様書は HPACK 、 HTTP/2 で使われる HTTP ヘッダ
                フィールドを効率的に表現する圧縮フォーマットを定義
                します。
            </t>
        </abstract>

      <note title="編集者ノート (RFC 編集者により今後削除されます)">
        <t>
          この草案の議論は <eref
          target="https://lists.w3.org/Archives/Public/ietf-http-wg/"/> に
          アーカイブされる HTTPBIS ワーキンググループのメーリングリスト 
          (ietf-http-wg@w3.org) でおこなわれます。
        </t>
        <t>
          ワーキンググループ情報は <eref
          target="http://tools.ietf.org/wg/httpbis/"/> 、特に HTTP/2 については
          <eref target="http://http2.github.io/"/> で見ることができます。
        </t>
        <t>
          このドラフトの変更は <xref
          target="changes.since.draft-ietf-httpbis-header-compression-09"/> に
          まとまっています。
        </t>
      </note>
    </front>

    <middle>
        <section title="はじめに">
            <t>
                HTTP/1.1 (<xref target="RFC7230"/> を見てください) において、
                ヘッダフィールドは圧縮されません。 Web ページは 12 から数百の
                リクエストを含むようになってきており、これらのリエストの
                余分なヘッダフィールドは不必要に帯域を消費し、レイテンシを
                大きく増加します。
            </t>

            <t>
                <xref target="SPDY">SPDY</xref> は最初、余分なヘッダフィールド
                を効率的に表現することで非常に効率的にする
                <xref target="DEFLATE">DEFLATE</xref> フォーマットを使用して
                ヘッダフィールドを圧縮することによりこの無駄に取り組みました。
                しかしながら、このアプローチは CRIME 攻撃で実証された通り
                セキュリティリスクに晒されます。 (<xref target="CRIME"/>を見て
                ください)
            </t>

            <t>
                この仕様書は HPACK 、余分なヘッダフィールドを消去し、既知の
                セキュリティ攻撃への脆弱性を抑え、そして制限された環境で
                使用する制限されたメモリ要求を持つヘッダフィールドの新しい
                圧縮方式を定義します。
            </t>

            <section title="概要">
                <t>
                    この仕様で定義されるフォーマットはヘッダフィールドのリストを
                    重複可能な名前と値のペアの整列済みコレクションとして扱います。
                    名前と値は不定のオクテットの並びになることを考慮し、ヘッダ
                    フィールドの順序は圧縮と展開の後で保存されます。
                </t>
                <t>
                    エンコーディングは名前と値のペアとインデックスされた値を
                    マップするヘッダテーブルに影響されます。これらの
                    ヘッダテーブルはエンコードまたはデコードされた新しい
                    ペアとして増分更新を行えます。
                </t>
                <t>
                    エンコードされた形式内で、ヘッダフィールドはリテラルもしくは
                    ヘッダテーブル内の一つの名前と値のペアへの参照として表現
                    されます。従って、ヘッダフィールドのリストは参照とリテラル値の
                    混合を用いてエンコードできます。
                </t>
                <t>
                    エンコーダはヘッダテーブルに新しいエントリとして挿入する
                    ヘッダフィールドを決定する責任があります。デコーダは
                    エンコーダによって定められたヘッダテーブルの修正を行い、
                    その処理内でヘッダフィールドのリストを再構築します。
                    これによりデコーダをシンプル化し、非常に様々なエンコーダと
                    相互運用可能にすることができます。
                </t>
                <t>
                    ヘッダフィールドを表現するためのこれらの異なったメカニズムの使用
                    を解説する例は <xref target="examples"/> にあります。
                </t>
            </section>

            <section title="表記" anchor="conventions">
                <t>
                    この文書のキーワード "MUST", "MUST NOT", "REQUIRED",
                    "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",
                    "MAY", そして "OPTIONAL" は <xref target="RFC2119">RFC 2119</xref>
                    に記述された通りに解釈されます。
                </t>
                <t>
                    全ての数値はネットワークバイトオーダーです。特に断りが
                    無い限り値は符号なしです。リテラルの値は必要に応じて
                    10 進数または 16 進数で与えられます。
                </t>

            </section>

            <section title="用語" anchor="encoding.concepts">
                <t>
                    この使用は下記の用語を使用します:
                    <list style="hanging">
                        <t hangText="ヘッダフィールド:">
                            名前と値のペア。名前と値どちらも不明瞭なオクテットの
                            連続として扱われます。
                        </t>
                        <t hangText="動的テーブル:">
                            動的テーブル (<xref target="dynamic.table"/> を見て
                            ください) は保存されたヘッダフィールドとインデックス
                            値を関連づけるのに使用されるヘッダテーブルです。
                            このテーブルは動的でエンコーディングやデコーディング
                            のコンテキストを指定します。
                        </t>
                        <t hangText="静的テーブル:">
                            静的テーブル(<xref target="static.table"/> を見て
                            ください) は静的なヘッダフィールドとインデックス
                            値を関連づけるのに使用されるヘッダテーブルです。
                            このテーブルは整列されて、リードオンリーであり、
                            常にアクセス可能で、すべてのエンコーディングや
                            デコーディングのコンテキストの間で共有されます。
                        </t>
                        <t hangText="ヘッダリスト:">
                            ヘッダリストは一緒にエンコードされるヘッダ
                            フィールドの整列済コレクションであり、重複した
                            ヘッダフィールドを含むことができます。
                            HTTP/2 ヘッダブロックに含まれるキーと値のペアの
                            完全なリストがヘッダリストです。
                        </t>
                        <t hangText="ヘッダフィールド表現:">
                            ヘッダフィールドはリテラルかインデックスの
                            どちらかのエンコードされた形式で表現できます。
                            (<xref target="header.representation"/> を見て
                            ください)
                        </t>
                        <t hangText="ヘッダブロック:">
                            デコードされた際にヘッダリストの計算に譲る
                            ヘッダフィールド表現の整列されたリストです。
                        </t>
                    </list>
                </t>
            </section>
        </section>

        <section title="圧縮処理の概要" anchor="header.encoding">
            <t>
                この仕様ではエンコーダの為の特定のアルゴリズムについては記述
                しません。代わりに、デコーダがどう処理することが期待され、
                この定義で許されるエンコーディングを行う為にエンコーダに許される
                ことを正確に定義します。
            </t>

            <section title="ヘッダリストの順序"
                anchor="header.list.ordering">
                <t>
                    HPACK はヘッダリスト内のヘッダフィールドの順序を保存します。
                    エンコーダはオリジナルのヘッダリスト内の順序によってヘッダ
                    ブロックのヘッダフィールド表現を整列しなければなりません。 (MUST)
                    デコーダはヘッダブロック内の順序によってデコードされたヘッダ
                    リスト内のヘッダフィールドを整列しなければなりません。 (MUST)
                </t>
            </section>

            <section title="エンコーディングとデコーディングのコンテキスト"
                anchor="encoding.context">
                <t>
                    ヘッダブロックを展開するため、デコーダはデコーディング
                    コンテキストとして動的テーブル (<xref
                        target="dynamic.table"/> を見てください) の管理のみを
                    必要とします。他に必要な状態はありません。
                </t>
                <t>
                    HTTP のような双方向コミュニケーションに使用される際、
                    エンコーディングとデコーディングの動的テーブルは
                    完全に独立したエンドポイントで管理されます。
                    例えば、リクエストとレスポンスの動的テーブルは分離されます。
                </t>
            </section>

            <section title="インデクシングテーブル"
                anchor="indexing.tables">
                <t>
                    HPACK はヘッダフィールドとインデックスを関連付ける二つの
                    テーブルを使用します。静的テーブル (<xref
                        target="static.table"/> を見てください) は予め定義されて
                    おり、 (ほとんどは空の値を持った) 共通のヘッダフィールドを
                    含みます。動的テーブル (<xref target="dynamic.table"/> を見て
                    ください) は動的であり、エンコーダによってエンコードされた
                    ヘッダリスト内で繰り返されるヘッダフィールドを指すのに
                    使用できます。
                </t>
                <t>
                    これら二つのテーブルはインデックス値の定義のため単一のアドレス
                    空間内で結合されます。 (<xref
                        target="index.address.space"/> を見てください)
                </t>

                <section title="静的テーブル" anchor="static.table">
                    <t>
                        静的テーブルは予め定義されたヘッダフィールドの静的
                        リストで構成されます。このエントリは <xref
                            target="static.table.definition"/> で定義
                        されます。
                    </t>
                </section>

                <section title="動的テーブル" anchor="dynamic.table">
                    <t>
                        動的テーブルは first-in first-out 順で管理される
                        ヘッダフィールドのリストで構成されます。動的テーブルの
                        最初と最新のエントリは最小のインデックスに、最古の
                        エントリは最大のインデックスになります。
                    </t>
                    <t>
                        動的テーブルは最初は空です。各ヘッダブロックとして追加
                        されるエントリは展開されます。
                    </t>
                    <t>
                        動的テーブルは重複するエントリを持つ可能性があります。
                        従って、重複したエントリはデコーダによってエラーとして
                        扱われてはいけません。 (MUST NOT)
                    </t>
                    <t>
                        エンコーダは動的テーブルの更新の仕方を決定するため、動的
                        テーブルに使用されるメモリ量を制御することができます。
                        デコーダのメモリ要件を制限するために、動的テーブルサイズは
                        厳格に束縛されます。 (<xref target="maximum.table.size"/> を
                        見てください)
                    </t>
                    <t>
                        ヘッダフィールド表現のリストの処理の間にデコーダは動的
                        テーブルを更新します。(<xref
                            target="header.representation.processing"/> を見て
                        ください)
                    </t>
                </section>

                <section title="インデックスアドレス空間"
                    anchor="index.address.space">
                    <t>
                        静的テーブルと動的テーブルは単一のインデックスアドレス
                        空間内で結合されます。
                    </t>
                    <t>
                        1 から静的テーブルの長さの間の指定は静的テーブル内の
                        要素を参照します。 (<xref target="static.table"/> を
                        見てください)
                    </t>
                    <t>
                        静的テーブルの長さより大きい指定は動的テーブル (<xref
                            target="dynamic.table"/> を見てください) 内の
                        要素を参照します。静的テーブルの長さは動的テーブルの
                        インデックスを検索するため差し引かれます。
                    </t>
                    <t>
                        両方のテーブルの長さの合計値より大きい指定はデコード
                        エラーとして扱われなければなりません (MUST) 。
                    </t>

                    <figure anchor="Index.Address.Space"
                            title="インデックスアドレス空間">
                        <preamble>
                            静的テーブルサイズ s 、動的テーブルサイズ k として、
                            下記の図は全体の有効なインデックスアドレス空間を
                            示しています。
                        </preamble>
                    <artwork type="drawing"><![CDATA[
        <----------  Index Address Space ---------->
        <-- Static  Table -->  <-- Dynamic Table -->
        +---+-----------+---+  +---+-----------+---+
        | 1 |    ...    | s |  |s+1|    ...    |s+k|
        +---+-----------+---+  +---+-----------+---+
                               ^                   |
                               |                   V
                        Insertion Point      Dropping Point
]]></artwork>
                    </figure>
                </section>
            </section>

            <section title="ヘッダフィールド表現"
                     anchor="header.representation">
                <t>
                    エンコードされたヘッダフィールドはリテラルもしくは
                    インデックスとして表現できます。
                </t>
                <t>
                    リテラル表現は名前と値を指定することでヘッダフィールドを
                    定義します。ヘッダフィールド名はリテラルもしくは静的テーブル
                    または動的テーブルのエントリへの参照として表現できます。
                    ヘッダフィールド値はリテラルで表現できます。
                </t>
                <t>
                    3 つの異なるリテラル表現は下記のように定義されます:
                    <list style="symbols">
                        <t>
                            動的テーブルへのヘッダフィールドの追加を行わない
                            リテラル表現。 (<xref
                                target="literal.header.without.indexing"/> を見て
                            ください)
                        </t>
                        <t>
                            動的テーブルへのヘッダフィールドの追加を行わず、
                            特に中継者に再エンコードされる際にヘッダフィールドが
                            常にリテラル表現を使用するような追加の制限を伴う
                            リテラル表現。 (<xref
                                target="literal.header.never.indexed"/> を見て
                            ください)
                        </t>
                        <t>
                            ヘッダフィールドを新しいエントリとして動的テーブルの
                            先頭に追加するリテラル表現(<xref
                                target="literal.header.with.incremental.indexing"/> を
                            見てください)。
                        </t>
                    </list>
                </t>
                <t>
                    インデックスされた表現は静的テーブルまたは動的テーブルの
                    エントリへの参照としてヘッダフィールドを定義します
                    (<xref target="indexed.header.representation"/> を見て
                    ください)。
                </t>
            </section>
        </section>

        <section title="ヘッダブロックデコーディング"
                 anchor="header.block.decoding">
            <section title="ヘッダブロック処理"
                anchor="header.block.processing">
                <t>
                    デコーダはオリジナルのヘッダリストに逐次的に再構成することで
                    ヘッダブロックを処理します。
                </t>
                <t>
                    いったんヘッダフィールドがデコードされ再構成されたヘッダ
                    リストに追加されたら、削除することはできません。
                    ヘッダリストに追加されたヘッダフィールドはアプリケーションに
                    安全に渡されます。
                </t>
                <t>
                    アプリケーションに結果のヘッダフィールドを渡すことで、
                    デコーダは動的テーブルに加えて最低限の一時的なメモリ消費で
                    実装できます。
                </t>
            </section>

            <section title="ヘッダフィールド表現の処理"
                     anchor="header.representation.processing">
                <t>
                    ヘッダリストを得るためのヘッダブロックの処理をこの節で
                    定義します。デコーディングがうまくヘッダリストを生成する
                    ことを確実にするため、デコーダは下記の規則に従わなければ
                    なりません (MUST) 。
                </t>
                <t>
                    ヘッダブロック内に含まれるすべてのヘッダフィールド表現は
                    下記に示す通り、現れた順に処理されます。様々なヘッダ
                    フィールド表現のフォーマットの詳細と、幾つかの追加の処理命令は
                    <xref target="detailed.format"/> にあります。
                </t>
                <t>
                    <spanx>インデックスされた表現</spanx> は 下記のアクションを
                    伴います:
                    <list style="symbols">
                        <t>
                            静的テーブルもしくは動的テーブルの参照されるエントリに
                            対応するヘッダフィールドはデコードされたヘッダリストに
                            追加される。
                        </t>
                    </list>
                </t>
                <t>
                    動的テーブルに<spanx>追加されていない</spanx> 
                    <spanx>リテラル表現</spanx> は下記のアクションを伴います:
                    <list style="symbols">
                        <t>
                            ヘッダフィールドはデコードされたヘッダリストに
                            追加されます。
                        </t>
                    </list>
                </t>
                <t>
                    動的テーブルに<spanx>追加されている</spanx> 
                    <spanx>リテラル表現</spanx> は下記のアクションを伴います:
                    <list style="symbols">
                        <t>
                            ヘッダフィールドはデコードされたヘッダリストに
                            追加されます。
                        </t>
                        <t>
                            ヘッダフィールドは動的テーブルの先頭に挿入されます。
                            この挿入は動的テーブルの以前のエントリの削除を
                            引き起こす可能性があります(<xref 
                                target="entry.addition"/> を見てください) 。
                        </t>
                    </list>
                </t>
            </section>
        </section>

        <section title="動的テーブルの管理"
                 anchor="dynamic.table.management">
            <t>
                デコーダ側のメモリ要件を制限するため、動的テーブルは
                サイズが制限されます。
            </t>

            <section title="テーブルサイズの計算"
                     anchor="calculating.table.size">
                <t>
                    動的テーブルのサイズはそのエントリのサイズの合計値です。
                </t>
                <t>
                    エントリのサイズはその名前のオクテットの長さ (<xref
                        target="string.literal.representation" /> で定義される
                    通り) と値のオクテットの長さ (<xref
                    target="string.literal.representation" /> を見てください)
                    の合計値です。
                </t>
                <t>
                    エントリのサイズはハフマンエンコーディングの適用無しの
                    名前と値の長さで計算されます。
                </t>
                <t>
                    注意: エントリに関連付いたオーバーヘッドとして追加の 32 
                    オクテットを付加します。例として、エントリの名前と値を
                    参照するための 2 つの 64 ビットポインタと、名前と値への
                    参照数を数える 2 つの 64 ビット整数を使うエントリ構造
                    は 32 オクテットのオーバーヘッドを持ちます。
                </t>
            </section>

            <section title="最大テーブルサイズ"
                     anchor="maximum.table.size">
                <t>
                    HPACK を使用するプロトコルは、エンコーダが動的テーブルに
                    使用することを許可される最大値を決定します。 HTTP/2 に
                    おいて、この値は SETTINGS_HEADER_TABLE_SIZE 設定 (<xref
                        target="HTTP2" x:fmt="of" x:rel="#SettingValues"/> を
                    見てください) で決定されます。
                </t>
                <t>
                    エンコーダはこの最大値より小さな容量を使用することを選択する
                    ことが可能です (<xref target="encoding.context.update"/> を
                    見てください) が、その値はプロトコルによって設定された最大値
                    以下に留めなければなりません (MUST) 。
                </t>
                <t>
                    動的テーブルの最大サイズはヘッダブロックのエンコーディング中を
                    除き任意のタイミングでプロトコルによって変更することが可能です。
                    エンコーダによって使用される動的テーブルの最大値を変更した
                    後は、エンコーダはエンコーディングコンテキスト更新 (<xref
                        target="encoding.context.update"/> を見てください) によって
                    この変更を通知しなければなりません (MUST) 。このエンコーディング
                    コンテキスト更新はヘッダテーブルサイズの変更が続く、最初の
                    ヘッダブロックの先頭で行わなければなりません (MUST) 。
                    HTTP/2 において、これは設定確認 (<xref
                        target="HTTP2" x:fmt="of" x:rel="#SettingsSync"/> を見て
                    ください) で追従します。
                </t>
                <t>
                    二つのヘッダブロックの送信の間に複数のテーブルサイズの最大値の
                    更新が起こる可能性があります。この場合このパラメータの値は
                    一度以上変更され、もし新しい最大サイズより小さい値があれば、
                    最小値がパラメータとしてエンコーディングコンテキスト更新内で
                    送信されなければなりません (MUST) 。変更された最大サイズは常に
                    送信され、多くて二つのエンコーディングコンテキスト更新が引き
                    起こされます。これはデコーダがデコーダテーブルサイズに基づき
                    削除を実行することを可能にするのを確実にします (<xref 
                        target="entry.eviction"/> を見てください) 。
                </t>
                <t>
                    このメカニズムで 0 の最大サイズを設定することで動的テーブル
                    からエントリを完全にクリアして、その後に再格納することが
                    できます。
                </t>
            </section>

            <section title="動的テーブルサイズ変更時のエントリの削除"
                     anchor="entry.eviction">
                <t>
                    動的テーブルの最大サイズが減少したらいつでも、動的テーブルの
                    サイズが最大サイズ以下になるまで動的テーブルの末尾から
                    エントリが削除されます。
                </t>
            </section>

            <section title="新しいエントリ追加時のエントリの削除"
                     anchor="entry.addition">
                <t>
                    動的テーブルに新しいエントリが追加されたらいつでも、
                    動的テーブルのサイズが (最大サイズ - 新しいエントリサイズ) 
                    以下になるかテーブルが空になるまで動的テーブルの末尾から
                    エントリが削除されます。
                </t>
                <t>
                    もし追加されたエントリの表現が動的テーブルのエントリの名前を
                    参照しているなら、参照される名前はその名前が不用意に削除される
                    のを避けるため削除を実行するより前にキャッシュされます。
                </t>
                <t>
                    もし新しいエントリのサイズが最大サイズ以下なら、エントリは
                    テーブルに追加されます。最大サイズより大きいエントリの
                    追加を試みることはエラーにはなりません; テーブル全体より
                    大きなエントリの追加の試みはすべてのエントリを空にすることに
                    なり、テーブルを空にする結果になります。
                </t>
            </section>
        </section>

        <section title="プリミティブ型表現"
                 anchor="low-level.representation">
            <t>
                HPACK エンコーディングは二つのプリミティブ型を使用します:
                符号なしの可変長整数とオクテットの文字列
            </t>

            <section title="整数表現"
                     anchor="integer.representation">
                <t>
                    整数は名前のインデックス、ペアのインデックスまたは文字列の
                    長さを表現するために使用されます。最適化された処理のため、
                    整数表現は常にオクテットの最後で終わります。
                </t>
                <t>
                    整数は 2 つのパートで表現されます: 現在のオクテットを埋める
                    プレフィックスとプレフィックス内に収まらない整数値の場合に
                    使用されるオクテットのオプショナルなリスト。プレフィックス
                    (N と呼ぶ) のビット数は整数表現のパラメータです。
                </t>
                <figure
                    anchor="Integer.Value.Encoded.within.the.Prefix.shown.for.N.5"
                    title="プレフィックス内のエンコードされた整数値 (N = 5 の場合)">
                    <artwork type="inline"><![CDATA[
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| ? | ? | ? |     Value (N)     |
+---+---+---+-------------------+
]]></artwork>
                </figure>
                <t>
                    整数値が十分小さい、厳密には 2<x:sup>N</x:sup>-1 未満の
                    場合、 N ビットプレフィックス内にエンコードされます。
                </t>
                <figure
                    anchor="Integer.Value.Encoded.after.the.Prefix.shown.for.N.5"
                    title="プレフィックスの後ろのエンコードされた整数値 (N = 5 の場合)">
                    <artwork type="inline"><![CDATA[
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| ? | ? | ? | 1   1   1   1   1 |
+---+---+---+-------------------+
| 1 |   Value-(2^N-1) LSB (7)   |
+---+---------------------------+
               ...
+---+---------------------------+
| 0 |   Value-(2^N-1) MSB (7)   |
+---+---------------------------+
]]></artwork>
                </figure>
                <t>
                    その他、プレフィックスの全てのビットが 1 にセットされている
                    ならその値は 2<x:sup>N</x:sup>-1 分減らされ、一個以上の
                    オクテットのリストを使用してエンコードされます。
                    各オクテットの最上位ビットは継続フラグとして使用されます:
                    リストの最終オクテットを除きこの値には 1 がセットされます。
                    残りのオクテットのビットは減算された値をエンコードするのに
                    使用されます。
                </t>
                <t>
                    オクテットのリストからの整数値のデコードはリストの
                    オクテットの逆順から開始します。その後、オクテット毎に
                    最上位ビットを除去します。オクテットの残りのビットは
                    連結され、その結果の値は整数値を得るために
                    2<x:sup>N</x:sup>-1 分加算されます。
                </t>
                <t>
                    プレフィックスサイズ N は常に 1 から 8 ビットの間です。
                    オクテット境界から開始する整数は 8 ビットの値を持ちます。
                </t>
                <figure>
                    <preamble>
                        整数 I を表現する擬似コードは下記の通り:
                    </preamble>
                    <artwork type = "inline"><![CDATA[
if I < 2^N - 1, encode I on N bits
else
    encode (2^N - 1) on N bits
    I = I - (2^N - 1)
    while I >= 128
         encode (I % 128 + 128) on 8 bits
         I = I / 128
    encode I on 8 bits
]]></artwork>
                </figure>
                <figure>
                    <preamble>
                        整数 I をデコードする擬似コードは下記の通り:
                    </preamble>
                    <artwork type="inline"><![CDATA[
decode I from the next N bits
if I < 2^N - 1, return I
else
    M = 0
    repeat
        B = next octet
        I = I + (B & 127) * 2^M
        M = M + 7
    while B & 128 == 128
    return I
]]></artwork>
                </figure>
                <t>
                    整数のエンコーディングを解説する例は
                    <xref target="integer.representation.examples"/> にあります。
                </t>
                <t>
                    この整数表現は不定サイズの値が許可されます。エンコーダは
                    ゼロ値の巨大な数値を送ることも可能ですが、オクテットを浪費し
                    整数値のオーバーフローを起こす可能性があります。
                    過度に巨大な整数をエンコーディングする - 値やオクテットの長さで -
                    のはデコードエラーとして扱われなければなりません。 (MUST)
                    制限の差異は実装上の制限に基づいて、各々の整数の使用方法の違いに
                    合わせることができます。
                </t>
            </section>

            <section title="文字列リテラル表現"
                     anchor="string.literal.representation">
                <t>
                    ヘッダフィールド名とヘッダフィールド値は文字列リテラルで
                    表現できます。文字列リテラルは直接文字列リテラルの
                    オクテットにエンコードされる、もしくはハフマン符号
                    (<xref target="HUFFMAN"/> を見てください) を
                    使用することでオクテットの連続としてエンコードされます。
                </t>
                <figure anchor="String.Literal.Representation"
                        title="文字列リテラル表現">
                    <artwork type="inline"><![CDATA[
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| H |    String Length (7+)     |
+---+---------------------------+
|  String Data (Length octets)  |
+-------------------------------+
]]></artwork>
                </figure>
                <t>
                    文字列リテラル表現は下記のフィールドを含みます:
                    <list style="hanging">
                        <t hangText="H:">
                            1 ビットフラグ H は文字列のオクテットがハフマン
                            エンコーディングされているかどうかを示します。
                        </t>
                        <t hangText="String Length:">
                            文字列リテラルをエンコードするのに使用された
                            オクテットの数です。 7 ビットプレフィックスで
                            整数としてエンコードされます。(<xref 
                                target="integer.representation"/> を見てください)
                        </t>
                        <t hangText="String Data:">
                            文字列リテラルのエンコードされたデータです。
                            もし H が '0' なら、エンコードされたデータは
                            文字列リテラルの生のオクテットです。もし H が 
                            '1' なら、エンコードされたデータは文字列リテラルを
                            ハフマンエンコーディングされています。
                        </t>
                    </list>
                </t>
                <t>
                    ハフマンエンコーディングを使用する文字列リテラルは
                    <xref target="huffman.code"/> で定義されるハフマン符号で
                    エンコードされます。(リクエストの例として <xref
                        target="request.examples.with.huffman.coding"/> を、
                    レスポンスの例として <xref
                        target="response.examples.with.huffman.coding"/> を見て
                    ください) エンコードされたデータは文字列リテラルの各
                    オクテットに対応する符号のビット単位の連続です。
                </t>
                <t>
                    ハフマンエンコードされたデータは常にオクテット境界で終わる
                    わけではないので、その後に次のオクテット境界までパディングが
                    挿入されます。このパディングが文字列リテラルの一部だと誤認
                    されることを防ぐため、符号の最上位ビットに EOS
                    (end-of-string) に対応するシンボルが使用されます。
                </t>
                <t>
                    デコーディングにおいて、エンコードされたデータの最後の
                    不完全なコードはパディングだとみなされ、破棄されます。
                    7 ビットより厳密に大きいパディングはデコードエラーとして
                    扱われなければなりません。 (MUST) EOS シンボルのコードの
                    最上位ビットに対応しないパディングはデコードエラーとして
                    扱われなければなりません。 (MUST) EOS シンボルを含む
                    ハフマンエンコードされた文字列リテラルはデコードエラーとして
                    扱われなければなりません。 (MUST) 
                </t>
            </section>
        </section>

        <section title="バイナリフォーマット" anchor="detailed.format">
            <t>
                この節は各々の異なるヘッダフィールド表現の詳細フォーマット
                に加え、エンコーディングコンテキストの更新命令について
                記述します。
            </t>

            <section title="インデックスされたヘッダフィールド表現"
                anchor="indexed.header.representation">
                <t>
                    インデックスされたヘッダフィールド表現は静的テーブル
                    または動的テーブルのエントリを識別します。(<xref
                        target="indexing.tables"/> を見てください)
                </t>
                <t>
                    インデックスされたヘッダフィールド表現は <xref
                        target="header.representation.processing"/> で
                    記述した通り、デコードされたヘッダリストへのヘッダ
                    フィールドの追加を引き起こします。
                </t>

                <figure anchor="Indexed.Header.Field"
                        title="インデックスされたヘッダフィールド">
                    <artwork type="inline"><![CDATA[
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 1 |        Index (7+)         |
+---+---------------------------+
]]></artwork>
                </figure>
                <t>
                    インデックスされたヘッダフィールドは 1 ビットパターン '1'
                    から開始し、マッチするペアのインデックスが後に続きます。
                    インデックスは 7 ビットプレフィックスの整数として表現
                    されます。(<xref target="integer.representation"/> を見て
                    ください)
                </t>
                <t>
                    0 のインデックス値は使用されません。もしインデックスヘッダ
                    フィールド表現でこれが見つかった場合、デコードエラーとして
                    扱われなければなりません。 (MUST)
                </t>
            </section>

            <section title="リテラルヘッダフィールド表現"
                anchor="literal.header.representation">
                <t>
                    リテラルヘッダフィールド表現はリテラルヘッダフィールド値を
                    含みます。ヘッダフィールド名はリテラル、もしくは静的テーブル
                    か動的テーブルに存在するテーブルエントリへの参照として
                    与えられます。 (<xref target="indexing.tables"/> を見てください)
                </t>

                <t>
                    この仕様ではリテラルヘッダフィールド表現の 3 つの形式、
                    インデックスを伴う、インデックスを伴わない、インデックスしない
                    ものを定義します。
                </t>

                <section title="増加インデクシングを伴うリテラルヘッダフィールド"
                    anchor="literal.header.with.incremental.indexing">
                    <t>
                        増加インデクシングを伴うリテラルヘッダフィールド表現は
                        デコードされたヘッダリストへのヘッダフィールドの追加と
                        動的テーブルへの新しいエントリの挿入を引き起こします。
                    </t>
                    <figure
                        anchor="Literal.Header.Field.with.Incremental.Indexing.Indexed.Name"
                        title="増加インデクシングを伴うリテラルヘッダフィールド - インデックスされた名前">
                        <artwork type="inline"><![CDATA[
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 1 |      Index (6+)       |
+---+---+-----------------------+
| H |     Value Length (7+)     |
+---+---------------------------+
| Value String (Length octets)  |
+-------------------------------+
]]></artwork>
                    </figure>
                    <figure
                        anchor="Literal.Header.Field.with.Incremental.Indexing.New.Name"
                        title="増加インデクシングを伴うリテラルヘッダフィールド - 新しい名前">
                        <artwork type="inline"><![CDATA[
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 1 |           0           |
+---+---+-----------------------+
| H |     Name Length (7+)      |
+---+---------------------------+
|  Name String (Length octets)  |
+---+---------------------------+
| H |     Value Length (7+)     |
+---+---------------------------+
| Value String (Length octets)  |
+-------------------------------+
]]></artwork>
                    </figure>
                    <t>
                        増加インデクシングを伴うリテラルヘッダフィールド表現は
                        2 ビットパターン '01' から開始します。
                    </t>
                    <t>
                        もし静的テーブルまたは動的テーブルに格納されたエントリの
                        ヘッダフィールド名に、ヘッダフィールド名とマッチする場合、
                        ヘッダフィールド名はそのエントリのインデックスを用いて
                        表現できます。この場合、エントリのインデックスは 6 ビット
                        プレフィックスの整数値として表現されます。 (<xref 
                            target="integer.representation"/> を見てください)
                        この値は常に非ゼロです。
                    </t>
                    <t>
                        そうでなければ、ヘッダフィールド名が文字列リテラル (<xref
                            target="string.literal.representation" /> を見て
                        ください)として表現されます。 6 ビットインデックスの
                        代わりに 0 値が使用され、ヘッダフィールド名が続きます。
                    </t>
                    <t>
                        どちらのヘッダフィールド名表現の形式も、文字列リテラル
                        (<xref target="string.literal.representation" /> を見て
                        ください) として表現されたヘッダフィールド値が続きます。
                    </t>
                </section>

                <section title="インデクシングを伴わないリテラルヘッダフィールド"
                    anchor="literal.header.without.indexing">
                    <t>
                        インデクシングを伴わないリテラルヘッダフィールド表現は、
                        動的テーブルの変更を伴わずにデコードされたヘッダリストへの
                        ヘッダフィールドの追加を引き起こします。
                    </t>
                    <figure
                        anchor="Literal.Header.Field.without.Indexing.Indexed.Name"
                        title="インデクシングを伴わないリテラルヘッダフィールド - インデックスされた名前">
                        <artwork type="inline"><![CDATA[
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 0 |  Index (4+)   |
+---+---+-----------------------+
| H |     Value Length (7+)     |
+---+---------------------------+
| Value String (Length octets)  |
+-------------------------------+
]]></artwork>
                    </figure>
                    <figure
                        anchor="Literal.Header.Field.without.Indexing.New.Name"
                        title="インデクシングを伴わないリテラルヘッダフィールド - 新しい名前">
                        <artwork type="inline"><![CDATA[
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 0 |       0       |
+---+---+-----------------------+
| H |     Name Length (7+)      |
+---+---------------------------+
|  Name String (Length octets)  |
+---+---------------------------+
| H |     Value Length (7+)     |
+---+---------------------------+
| Value String (Length octets)  |
+-------------------------------+
]]></artwork>
                    </figure>
                    <t>
                        インデクシングを伴わないリテラルヘッダフィールド表現は
                        4 ビットパターン '0000' から開始します。
                    </t>
                    <t>
                        もし静的テーブルまたは動的テーブルに格納されたエントリの
                        ヘッダフィールド名に、ヘッダフィールド名とマッチする場合、
                        ヘッダフィールド名はそのエントリのインデックスを用いて
                        表現できます。この場合、エントリのインデックスは 4 ビット
                        プレフィックスの整数値として表現されます。 (<xref 
                            target="integer.representation"/> を見てください)
                        この値は常に非ゼロです。
                    </t>
                    <t>
                        そうでなければ、ヘッダフィールド名が文字列リテラル (<xref
                            target="string.literal.representation" /> を見て
                        ください)として表現されます。 4 ビットインデックスの
                        代わりに 0 値が使用され、ヘッダフィールド名が続きます。
                    </t>
                    <t>
                        どちらのヘッダフィールド名表現の形式も、文字列リテラル
                        (<xref target="string.literal.representation" /> を見て
                        ください) として表現されたヘッダフィールド値が続きます。
                    </t>
                </section>

                <section title="インデックスされないリテラルヘッダフィールド"
                    anchor="literal.header.never.indexed">
                    <t>
                        インデックスされないリテラルヘッダフィールド表現は
                        動的テーブルの変更を伴わずにデコードされたヘッダリストへの
                        ヘッダフィールドの追加を引き起こします。
                        中継者はこのヘッダフィールドのエンコードに同じ表現を
                        使用しなければなりません。 (MUST)
                    </t>
                    <figure
                        anchor="Literal.Header.Field.never.Indexed.Indexed.Name"
                        title="インデックスされないリテラルヘッダフィールド - インデックスされた名前">
                        <artwork type="inline"><![CDATA[
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 1 |  Index (4+)   |
+---+---+-----------------------+
| H |     Value Length (7+)     |
+---+---------------------------+
| Value String (Length octets)  |
+-------------------------------+
]]></artwork>
                    </figure>
                    <figure
                        anchor="Literal.Header.Field.never.Indexed.New.Name"
                        title="インデックスされないリテラルヘッダフィールド - 新しい名前">
                        <artwork type="inline"><![CDATA[
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 1 |       0       |
+---+---+-----------------------+
| H |     Name Length (7+)      |
+---+---------------------------+
|  Name String (Length octets)  |
+---+---------------------------+
| H |     Value Length (7+)     |
+---+---------------------------+
| Value String (Length octets)  |
+-------------------------------+
]]></artwork>
                    </figure>
                    <t>
                        インデックスされないリテラルヘッダフィールド表現は
                        4 ビットパターン '0001' から開始します。
                    </t>
                    <t>
                        ヘッダフィールドがインデックスされないリテラルヘッダ
                        フィールドとして表現される際、常にこのリテラル表現で
                        エンコードされなければなりません。 (MUST) 特に、
                        ピアがインデックスされないリテラルヘッダフィールド
                        として表現されたヘッダフィールドを受け取ってそれを
                        送信する際、このヘッダフィールドを転送するために同じ
                        表現を使用しなければなりません。 (MUST)
                    </t>
                    <t>
                        この表現は圧縮されることによるリスクに晒されないよう
                        ヘッダフィールド値を保護することを意図しています。
                        (詳細は <xref target="compression.based.attacks"/> を
                        見てください)
                    </t>
                    <t>
                        この表現のエンコーディングはインデクシングを伴わない
                        リテラルヘッダフィールドと同様です。(<xref 
                            target="literal.header.without.indexing"/> を見て
                        ください)
                    </t>
                </section>
            </section>

            <section title="動的テーブルサイズ更新"
                anchor="encoding.context.update">
                <t>
                    動的テーブルサイズ更新は動的テーブルのサイズの変更を
                    通知します。
                </t>
                <figure anchor="Maximum.Dynamic.Table.Size.Change"
                        title="最大動的テーブルサイズの変更">
                    <artwork type="inline"><![CDATA[
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 0 | 1 |   Max size (5+)   |
+---+---------------------------+
]]></artwork>
                </figure>
                <t>
                    動的テーブルサイズ更新は 3 ビットパターン '001' から開始し、
                    5 ビットプレフィックスの整数値 (<xref
                        target="integer.representation"/> を見てください) として
                    表現される新しい最大値が続きます。
                </t>
                <t>
                    新しい最大値はデコーダが受け取りエンコーダが知らせた 
                    (<xref target="HTTP2" x:fmt="of"
                        x:rel="#SettingsSync"/> を見てください)
                    SETTINGS_HEADER_TABLE_SIZE パラメータ (<xref
                        target="HTTP2" x:fmt="of" x:rel="#SettingValues"/> を見て
                    ください)の最後の値以下でなければなりません。 (MUST)
                </t>
                <t>
                    動的テーブルの最大サイズの減少はエントリの削除を引き起こす
                    可能性があります。 (<xref target="entry.eviction"/> を見て
                    ください)
                </t>
            </section>
        </section>

        <section anchor="Security" title="セキュリティへの配慮">

            <t>
                この節では HPACK の潜在的なセキュリティへの懸念部分について
                記述します。
                <list style="symbols">
                    <t>
                        Use of compression as a length-based oracle for
                        verifying guesses about secrets that are compressed
                        into a shared compression context.
                    </t>
                    <t>
                        Denial of service resulting from exhausting processing
                        or memory capacity at a decoder.
                    </t>
                </list>
            </t>

            <section title="厳密な動的テーブルの状態"
                anchor="compression.based.attacks">

                <t>
                    HPACK reduces the length of header field encodings by
                    exploiting the redundancy inherent in protocols like HTTP.
                    The ultimate goal of this is to reduce the amount of data
                    that is required to send HTTP requests or responses.
                </t>
                <t>
                    The compression context used to encode header fields can be
                    probed by an attacker who can both define header fields to
                    be encoded and transmitted and observe the length of those
                    fields once they are encoded. When an attacker can do both,
                    they can adaptively modify requests in order to confirm
                    guesses about the dynamic table state. If a guess is
                    compressed into a shorter length, the attacker can observe
                    the encoded length and infer that the guess was correct.
                </t>
                <t>
                    This is possible even over TLS, because while TLS provides
                    confidentiality protection for content, it only provides a
                    limited amount of protection for the length of that content.
                    <list style="hanging">
                        <t hangText="Note:">
                            Padding schemes only provide limited protection
                            against an attacker with these capabilities,
                            potentially only forcing an increased number of
                            guesses to learn the length associated with a given
                            guess.  Padding schemes also work directly against
                            compression by increasing the number of bits that
                            are transmitted.
                        </t>
                    </list>
                </t>
                <t>
                    Attacks like <xref target="CRIME">CRIME</xref> demonstrated
                    the existence of these general attacker capabilities.  The
                    specific attack exploited the fact that <xref
                        target="DEFLATE">DEFLATE</xref> removes redundancy based
                    on prefix matching.  This permitted the attacker to confirm
                    guesses a character at a time, reducing an exponential-time
                    attack into a linear-time attack.
                </t>

                <section title="HPACK と HTTP への適応性">
                    <t>
                        HPACK mitigates but does not completely prevent attacks
                        modelled on <xref target="CRIME">CRIME</xref> by forcing
                        a guess to match an entire header field value, rather
                        than individual characters.  An attacker can only learn
                        whether a guess is correct or not, so is reduced to a
                        brute force guess for the header field values.
                    </t>
                    <t>
                        The viability of recovering specific header field values
                        therefore depends on the entropy of values.  As a
                        result, values with high entropy are unlikely to be
                        recovered successfully.  However, values with low
                        entropy remain vulnerable.
                    </t>
                    <t>
                        Attacks of this nature are possible any time that two
                        mutually distrustful entities control requests or
                        responses that are placed onto a single HTTP/2
                        connection.  If the shared HPACK compressor permits one
                        entity to add entries to the dynamic table, and the
                        other to access those entries, then the state of the
                        table can be learned.
                    </t>
                    <t>
                        Having requests or responses from mutually distrustful
                        entities occurs when an intermediary either:
                        <list style="symbols">
                            <t>
                                sends requests from multiple clients on a single
                                connection toward an origin server, or
                            </t>
                            <t>
                                takes responses from multiple origin servers and
                                places them on a shared connection toward a
                                client.
                            </t>
                        </list>
                        Web browsers also need to assume that requests made on
                        the same connection by different <xref
                        target="ORIGIN">web origins</xref> are made by mutually
                        distrustful entities.
                    </t>
                </section>

                <section title="Mitigation">
                    <t>
                        Users of HTTP that require confidentiality for header
                        fields can use values with entropy sufficient to make
                        guessing infeasible.  However, this is impractical as a
                        general solution because it forces all users of HTTP to
                        take steps to mitigate attacks.  It would impose new
                        constraints on how HTTP is used.
                    </t>
                    <t>
                        Rather than impose constraints on users of HTTP, an
                        implementation of HPACK can instead constrain how
                        compression is applied in order to limit the potential
                        for dynamic table probing.
                    </t>
                    <t>
                        An ideal solution segregates access to the dynamic table
                        based on the entity that is constructing header fields.
                        Header field values that are added to the table are
                        attributed to an entity, and only the entity that
                        created a particular value can extract that value.
                    </t>
                    <t>
                        To improve compression performance of this option,
                        certain entries might be tagged as being public.  For
                        example, a web browser might make the values of the
                        Accept-Encoding header field available in all requests.
                    </t>
                    <t>
                        An encoder without good knowledge of the provenance of
                        header fields might instead introduce a penalty for bad
                        guesses, such that attempts to guess a header field
                        value results in all values being removed from
                        consideration in all future requests, effectively
                        preventing further guesses.
                        <list style="hanging">
                            <t hangText="Note:">
                                Simply removing values from the dynamic table
                                can be ineffectual if the attacker has a
                                reliable way of causing values to be
                                reinstalled.  For example, a request to load an
                                image in a web browser typically includes the
                                Cookie header field (a potentially highly valued
                                target for this sort of attack), and web sites
                                can easily force an image to be loaded, thereby
                                refreshing the entry in the dynamic table.
                            </t>
                        </list>
                    </t>
                    <t>
                        This response might be made inversely proportional to
                        the length of the header field.  Marking as inaccessible
                        might occur for shorter values more quickly or with
                        higher probability than for longer values.
                    </t>
                    <t>
                        Implementations might also choose to protect certain
                        header fields that are known to be highly valued, such
                        as the Authorization or Cookie header fields, by
                        disabling or further limiting compression.
                    </t>
                </section>

                <section title="Never Indexed Literals">
                    <t>
                        Refusing to generate an indexed representation for a
                        header field is only effective if compression is avoided
                        on all hops.  The never indexed literal (see <xref
                            target="literal.header.never.indexed"/>) can be used
                        to signal to intermediaries that a particular value was
                        intentionally sent as a literal.  An intermediary MUST
                        NOT re-encode a value that uses the never indexed
                        literal with a representation that would index it.
                    </t>
                </section>
            </section>

            <section title="静的ハフマンエンコーディング">
                <t>
                    固定ハフマンエンコーディングに対する現在知られている攻撃は
                    ありません。固定ハフマンエンコーディングテーブルを用いる
                    ことが情報漏えいを引き起こすことを示した研究がありますが、
                    攻撃者は意味のある情報を復元するためにこの情報漏えいを
                    利用することはできないと結論付けています (<xref
                    target="PETAL"/> を見てください) 。
                </t>
            </section>

            <section title="メモリ消費">
                <t>
                    攻撃者はエンドポイントがメモリを使い尽くすことを引き起こす
                    ことを試すことができます。 HPACK はエンドポイントで
                    割り当てられたメモリ量のピークと状態を制限するよう設計
                    されています。
                </t>
                <t>
                    The amount of memory used by the compressor state is limited
                    by the decoder using the value of the HTTP/2 setting
                    parameter SETTINGS_HEADER_TABLE_SIZE (see <xref
                        target="HTTP2" x:fmt="of" x:rel="#SettingValues"/>).
                    This limit takes into account both the size of the data
                    stored in the dynamic table, plus a small allowance for
                    overhead.
                </t>
                <t>
                    A decoder can limit the amount of state memory used by
                    setting an appropriate value for the
                    SETTINGS_HEADER_TABLE_SIZE parameter.  An encoder can limit
                    the amount of state memory it uses by signalling lower
                    dynamic table size than the decoder allows (see <xref
                        target="encoding.context.update"/>).
                </t>
                <t>
                    The amount of temporary memory consumed by an encoder or
                    decoder can be limited by processing header fields
                    sequentially.  An implementation does not need to retain a
                    complete list of header fields.  Note however that it might
                    be necessary for an application to retain a complete header
                    list for other reasons; even though HPACK does not force
                    this to occur, application constraints might make this
                    necessary.
                </t>
            </section>

            <section title="実装上の制限">
                <t>
                    An implementation of HPACK needs to ensure that large values
                    for integers, long encoding for integers, or long string
                    literals do not create security weaknesses.
                </t>
                <t>
                    An implementation has to set a limit for the values it
                    accepts for integers, as well as for the encoded length (see
                    <xref target="integer.representation"/>).  In the same way,
                    it has to set a limit to the length it accepts for string
                    literals (see <xref
                        target="string.literal.representation"/>).
                </t>
            </section>

        </section>

        <section title="謝辞">
            <t>
                This specification includes substantial input from the following
                individuals:
                <list style="symbols">
                    <t>
                        Mike Bishop, Jeff Pinner, Julian Reschke, Martin Thomson
                        (substantial editorial contributions).
                    </t>
                    <t>
                        Johnny Graettinger (Huffman code statistics).
                    </t>
                </list>
            </t>
        </section>
    </middle>

    <back>
        <references title="引用文献">
            <reference anchor="HTTP2">
                <front>
                    <title>Hypertext Transfer Protocol version 2</title>
                    <author initials="M." surname="Belshe" fullname="Mike Belshe">
                        <organization>Twist</organization>
                    </author>
                    <author initials="R." surname="Peon" fullname="Roberto Peon">
                        <organization>Google</organization>
                    </author>
                    <author initials="M." surname="Thomson" fullname="Martin Thomson" role="editor">
                        <organization>Mozilla</organization>
                    </author>
                    <date month="October" year="2014"/>
                </front>
                <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-http2-16"/>
                <x:source href="refs/draft-ietf-httpbis-http2-16.xml"/>
            </reference>

            <reference anchor="RFC7230">
              <front>
                <title>
                    Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and
                    Routing
                </title>
                <author fullname="Roy T. Fielding" initials="R." role="editor" surname="Fielding">
                  <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
                  <address><email>fielding@gbiv.com</email></address>
                </author>
                <author fullname="Julian F. Reschke" initials="J. F." role="editor" surname="Reschke">
                  <organization abbrev="greenbytes">greenbytes GmbH</organization>
                  <address><email>julian.reschke@greenbytes.de</email></address>
                </author>
                <date month="June" year="2014" />
              </front>
              <seriesInfo name="RFC" value="7230" />
              <x:source href="refs/rfc7230.xml"
                basename="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7230"/>
            </reference>

            <reference anchor="RFC2119">
              <front>
                <title>
                  Key words for use in RFCs to Indicate Requirement Levels
                </title>
                <author initials="S." surname="Bradner" fullname="Scott Bradner">
                  <organization>Harvard University</organization>
                  <address><email>sob@harvard.edu</email></address>
                </author>
                <date month="March" year="1997"/>
              </front>
              <seriesInfo name="BCP" value="14"/>
              <seriesInfo name="RFC" value="2119"/>
            </reference>

        </references>

        <references title="参考文献">
            <reference anchor="SPDY">
                <front>
                    <title>SPDY Protocol</title>
                    <author initials="M." surname="Belshe" fullname="Mike Belshe">
                        <organization>Twist</organization>
                    </author>
                    <author initials="R." surname="Peon" fullname="Roberto Peon">
                        <organization>Google</organization>
                    </author>
                    <date month="February" year="2012"/>
                </front>
                <seriesInfo name="Internet-Draft" value="draft-mbelshe-httpbis-spdy-00"/>
            </reference>
            <reference anchor="ORIGIN">
                <front>
                    <title>The Web Origin Concept</title>
                    <author initials="A." surname="Barth" fullname="Adam Barth"/>
                    <date month="December" year="2011"/>
                </front>
                <seriesInfo name="RFC" value="6454"/>
            </reference>
            <reference anchor="DEFLATE">
                <front>
                    <title>DEFLATE Compressed Data Format Specification version 1.3</title>
                    <author initials="P." surname="Deutsch" fullname="L. Peter Deutsch">
                        <organization>Aladdin Enterprises</organization>
                    </author>
                    <date month="May" year="1996"/>
                </front>
                <seriesInfo name="RFC" value="1951"/>
            </reference>
            <reference anchor="CRIME" target="https://docs.google.com/a/twist.com/presentation/d/11eBmGiHbYcHR9gL5nDyZChu_-lCa2GizeuOfaLU2HOU/edit#slide=id.g1eb6c1b5_3_6">
                <front>
                    <title>The CRIME Attack</title>
                    <author initials="J." surname="Rizzo" fullname="Juliano Rizzo"></author>
                    <author initials="T." surname="Duong" fullname="Thai Duong"></author>
                    <date month="September" year="2012"/>
                </front>
            </reference>

            <reference anchor="HUFFMAN" target="https://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=4051119">
                <front>
                    <title>A Method for the Construction of Minimum Redundancy
                    Codes</title>
                    <author surname="Huffman" initials="D. A." fullname="David A. Huffman"/>
                    <date month="September" year="1952"/>
                </front>
                <seriesInfo name="Proceedings of the Institute of Radio Engineers" value="Volume 40, Number 9, pp. 1098-1101"/>
            </reference>

            <reference anchor="CANONICAL" target="https://dl.acm.org/citation.cfm?id=363991">
                <front>
                    <title>Generating a canonical prefix encoding</title>
                    <author surname="Schwartz" initials="E. S." fullname="Eugene. S. Schwartz"/>
                    <author surname="Kallick" initials="B." fullname="Bruce Kallick"/>
                    <date month="March" year="1964"/>
                </front>
                <seriesInfo name="Communications of the ACM" value="Volume 7 Issue 3, pp. 166-169"/>
            </reference>

            <reference anchor="PETAL" target="http://www.pdl.cmu.edu/PDL-FTP/associated/CMU-PDL-13-106.pdf">
                <front>
                    <title>PETAL: Preset Encoding Table Information
                    Leakage</title>
                    <author surname="Tan" initials="J." fullname="Jiaqi Tan"/>
                    <author surname="Nahata" initials="J."
                        fullname="Jayvardhan Nahata"/>
                    <date month="April" year="2013"/>
                </front>
            </reference>
        </references>

        <section title="静的テーブル定義" anchor="static.table.definition">
            <t>
                静的テーブル (<xref target="static.table"/> を見てください) は
                予め定義されており変更不可能なヘッダフィールドのリストで
                構成されます。
            </t>
            <t>
                静的テーブルは HTTP/2 コネクション内で交換されるメッセージとして
                有効な、最も共通して使用されるヘッダフィールドをリスト化することで
                作成されました。少数のヘッダフィールドの値は頻繁に使用される値として
                エントリに追加されています。その他のヘッダフィールドは、空の値で
                追加されています。
            </t>
            <t>
                下記のテーブルは静的テーブルを構成する予め定義されたヘッダ
                フィールドを列挙しています。
            </t>
            <texttable title="静的テーブルエントリ"
                anchor="static.table.entries">
                <!-- An easy way to renumber these in vim, with mark a and b
                     delimiting the table entries:
                      :let @a=1 | 'a,'bs/>[0-9 ][0-9 ]*</\='>'.(@a+setreg('a',@a+1)).'<'/
                -->
                <ttcol>インデックス</ttcol>
                <ttcol>ヘッダ名</ttcol>
                <ttcol>ヘッダ値</ttcol>

                <c>1</c><c>:authority</c><c></c>
                <c>2</c><c>:method</c><c>GET</c>
                <c>3</c><c>:method</c><c>POST</c>
                <c>4</c><c>:path</c><c>/</c>
                <c>5</c><c>:path</c><c>/index.html</c>
                <c>6</c><c>:scheme</c><c>http</c>
                <c>7</c><c>:scheme</c><c>https</c>
                <c>8</c><c>:status</c><c>200</c>
                <c>9</c><c>:status</c><c>204</c>
                <c>10</c><c>:status</c><c>206</c>
                <c>11</c><c>:status</c><c>304</c>
                <c>12</c><c>:status</c><c>400</c>
                <c>13</c><c>:status</c><c>404</c>
                <c>14</c><c>:status</c><c>500</c>
                <c>15</c><c>accept-charset</c><c></c>
                <c>16</c><c>accept-encoding</c><c>gzip, deflate</c>
                <c>17</c><c>accept-language</c><c></c>
                <c>18</c><c>accept-ranges</c><c></c>
                <c>19</c><c>accept</c><c></c>
                <c>20</c><c>access-control-allow-origin</c><c></c>
                <c>21</c><c>age</c><c></c>
                <c>22</c><c>allow</c><c></c>
                <c>23</c><c>authorization</c><c></c>
                <c>24</c><c>cache-control</c><c></c>
                <c>25</c><c>content-disposition</c><c></c>
                <c>26</c><c>content-encoding</c><c></c>
                <c>27</c><c>content-language</c><c></c>
                <c>28</c><c>content-length</c><c></c>
                <c>29</c><c>content-location</c><c></c>
                <c>30</c><c>content-range</c><c></c>
                <c>31</c><c>content-type</c><c></c>
                <c>32</c><c>cookie</c><c></c>
                <c>33</c><c>date</c><c></c>
                <c>34</c><c>etag</c><c></c>
                <c>35</c><c>expect</c><c></c>
                <c>36</c><c>expires</c><c></c>
                <c>37</c><c>from</c><c></c>
                <c>38</c><c>host</c><c></c>
                <c>39</c><c>if-match</c><c></c>
                <c>40</c><c>if-modified-since</c><c></c>
                <c>41</c><c>if-none-match</c><c></c>
                <c>42</c><c>if-range</c><c></c>
                <c>43</c><c>if-unmodified-since</c><c></c>
                <c>44</c><c>last-modified</c><c></c>
                <c>45</c><c>link</c><c></c>
                <c>46</c><c>location</c><c></c>
                <c>47</c><c>max-forwards</c><c></c>
                <c>48</c><c>proxy-authenticate</c><c></c>
                <c>49</c><c>proxy-authorization</c><c></c>
                <c>50</c><c>range</c><c></c>
                <c>51</c><c>referer</c><c></c>
                <c>52</c><c>refresh</c><c></c>
                <c>53</c><c>retry-after</c><c></c>
                <c>54</c><c>server</c><c></c>
                <c>55</c><c>set-cookie</c><c></c>
                <c>56</c><c>strict-transport-security</c><c></c>
                <c>57</c><c>transfer-encoding</c><c></c>
                <c>58</c><c>user-agent</c><c></c>
                <c>59</c><c>vary</c><c></c>
                <c>60</c><c>via</c><c></c>
                <c>61</c><c>www-authenticate</c><c></c>
            </texttable>
            <t>
                <xref target="static.table.entries"/> は静的テーブル内の
                各エントリのインデックスを与えます。
            </t>
        </section>

        <section title="ハフマン符号" anchor="huffman.code">
            <t>
                下記のハフマン符号はハフマン符号化を伴う文字列リテラルの
                エンコーディング時に使用されます(<xref
                    target="string.literal.representation"/> を見てください)。
            </t>
            <t>
                このハフマン符号は HTTP ヘッダの多くのサンプルで得られた
                統計から生成されました。これはユニークなコード長を持つシンボルが
                無いことを確実にするよう幾つかの微調整を行ったカノニカルハフマン
                符号 (<xref target="CANONICAL"/> を見てください) です。
            </t>
            <t>
                テーブルの各行はシンボルを表現するのに使用されるコードを定義します:
                <list style="hanging">
                    <t hangText="sym:">
                        表現されるシンボル。オクテットの 10 進数値です。可能で
                        あればアスキー表現でも表記しています。特別なシンボル
                        "EOS" は文字列リテラルの終わりを示すのに使用されます。
                    </t>
                    <t hangText="code as bits:">
                        2 進数で表現されたシンボルのハフマンコード。
                        最上位ビット (MSB) で調整されています。
                    </t>
                    <t hangText="code as hex:">
                        16 進数で表現されたシンボルのハフマンコード。
                        最下位ビット (LSB) で調整されています。
                    </t>
                    <t hangText="len:">
                        シンボルを表現するコードのビット数。
                    </t>
                </list>
            </t>
            <t>
                例として、シンボル 47 (アスキー文字 "/" に対応します) のコードは
                6 ビット  "0", "1", "1", "0", "0", "0" から構成されます。
                これは 6 ビットでエンコードされた値 0x18 (16 進数で) に対応します。
            </t>
            <figure>
                <artwork><![CDATA[
                                                     code
                       code as bits                 as hex   len
     sym              aligned to MSB                aligned   in
                                                    to LSB   bits
    (  0)  |11111111|11000                             1ff8  [13]
    (  1)  |11111111|11111111|1011000                7fffd8  [23]
    (  2)  |11111111|11111111|11111110|0010         fffffe2  [28]
    (  3)  |11111111|11111111|11111110|0011         fffffe3  [28]
    (  4)  |11111111|11111111|11111110|0100         fffffe4  [28]
    (  5)  |11111111|11111111|11111110|0101         fffffe5  [28]
    (  6)  |11111111|11111111|11111110|0110         fffffe6  [28]
    (  7)  |11111111|11111111|11111110|0111         fffffe7  [28]
    (  8)  |11111111|11111111|11111110|1000         fffffe8  [28]
    (  9)  |11111111|11111111|11101010               ffffea  [24]
    ( 10)  |11111111|11111111|11111111|111100      3ffffffc  [30]
    ( 11)  |11111111|11111111|11111110|1001         fffffe9  [28]
    ( 12)  |11111111|11111111|11111110|1010         fffffea  [28]
    ( 13)  |11111111|11111111|11111111|111101      3ffffffd  [30]
    ( 14)  |11111111|11111111|11111110|1011         fffffeb  [28]
    ( 15)  |11111111|11111111|11111110|1100         fffffec  [28]
    ( 16)  |11111111|11111111|11111110|1101         fffffed  [28]
    ( 17)  |11111111|11111111|11111110|1110         fffffee  [28]
    ( 18)  |11111111|11111111|11111110|1111         fffffef  [28]
    ( 19)  |11111111|11111111|11111111|0000         ffffff0  [28]
    ( 20)  |11111111|11111111|11111111|0001         ffffff1  [28]
    ( 21)  |11111111|11111111|11111111|0010         ffffff2  [28]
    ( 22)  |11111111|11111111|11111111|111110      3ffffffe  [30]
    ( 23)  |11111111|11111111|11111111|0011         ffffff3  [28]
    ( 24)  |11111111|11111111|11111111|0100         ffffff4  [28]
    ( 25)  |11111111|11111111|11111111|0101         ffffff5  [28]
    ( 26)  |11111111|11111111|11111111|0110         ffffff6  [28]
    ( 27)  |11111111|11111111|11111111|0111         ffffff7  [28]
    ( 28)  |11111111|11111111|11111111|1000         ffffff8  [28]
    ( 29)  |11111111|11111111|11111111|1001         ffffff9  [28]
    ( 30)  |11111111|11111111|11111111|1010         ffffffa  [28]
    ( 31)  |11111111|11111111|11111111|1011         ffffffb  [28]
' ' ( 32)  |010100                                       14  [ 6]
'!' ( 33)  |11111110|00                                 3f8  [10]
'"' ( 34)  |11111110|01                                 3f9  [10]
'#' ( 35)  |11111111|1010                               ffa  [12]
'$' ( 36)  |11111111|11001                             1ff9  [13]
'%' ( 37)  |010101                                       15  [ 6]
'&' ( 38)  |11111000                                     f8  [ 8]
''' ( 39)  |11111111|010                                7fa  [11]
'(' ( 40)  |11111110|10                                 3fa  [10]
')' ( 41)  |11111110|11                                 3fb  [10]
'*' ( 42)  |11111001                                     f9  [ 8]
'+' ( 43)  |11111111|011                                7fb  [11]
',' ( 44)  |11111010                                     fa  [ 8]
'-' ( 45)  |010110                                       16  [ 6]
'.' ( 46)  |010111                                       17  [ 6]
'/' ( 47)  |011000                                       18  [ 6]
'0' ( 48)  |00000                                         0  [ 5]
'1' ( 49)  |00001                                         1  [ 5]
'2' ( 50)  |00010                                         2  [ 5]
'3' ( 51)  |011001                                       19  [ 6]
'4' ( 52)  |011010                                       1a  [ 6]
'5' ( 53)  |011011                                       1b  [ 6]
'6' ( 54)  |011100                                       1c  [ 6]
'7' ( 55)  |011101                                       1d  [ 6]
'8' ( 56)  |011110                                       1e  [ 6]
'9' ( 57)  |011111                                       1f  [ 6]
':' ( 58)  |1011100                                      5c  [ 7]
';' ( 59)  |11111011                                     fb  [ 8]
'<' ( 60)  |11111111|1111100                           7ffc  [15]
'=' ( 61)  |100000                                       20  [ 6]
'>' ( 62)  |11111111|1011                               ffb  [12]
'?' ( 63)  |11111111|00                                 3fc  [10]
'@' ( 64)  |11111111|11010                             1ffa  [13]
'A' ( 65)  |100001                                       21  [ 6]
'B' ( 66)  |1011101                                      5d  [ 7]
'C' ( 67)  |1011110                                      5e  [ 7]
'D' ( 68)  |1011111                                      5f  [ 7]
'E' ( 69)  |1100000                                      60  [ 7]
'F' ( 70)  |1100001                                      61  [ 7]
'G' ( 71)  |1100010                                      62  [ 7]
'H' ( 72)  |1100011                                      63  [ 7]
'I' ( 73)  |1100100                                      64  [ 7]
'J' ( 74)  |1100101                                      65  [ 7]
'K' ( 75)  |1100110                                      66  [ 7]
'L' ( 76)  |1100111                                      67  [ 7]
'M' ( 77)  |1101000                                      68  [ 7]
'N' ( 78)  |1101001                                      69  [ 7]
'O' ( 79)  |1101010                                      6a  [ 7]
'P' ( 80)  |1101011                                      6b  [ 7]
'Q' ( 81)  |1101100                                      6c  [ 7]
'R' ( 82)  |1101101                                      6d  [ 7]
'S' ( 83)  |1101110                                      6e  [ 7]
'T' ( 84)  |1101111                                      6f  [ 7]
'U' ( 85)  |1110000                                      70  [ 7]
'V' ( 86)  |1110001                                      71  [ 7]
'W' ( 87)  |1110010                                      72  [ 7]
'X' ( 88)  |11111100                                     fc  [ 8]
'Y' ( 89)  |1110011                                      73  [ 7]
'Z' ( 90)  |11111101                                     fd  [ 8]
'[' ( 91)  |11111111|11011                             1ffb  [13]
'\' ( 92)  |11111111|11111110|000                     7fff0  [19]
']' ( 93)  |11111111|11100                             1ffc  [13]
'^' ( 94)  |11111111|111100                            3ffc  [14]
'_' ( 95)  |100010                                       22  [ 6]
'`' ( 96)  |11111111|1111101                           7ffd  [15]
'a' ( 97)  |00011                                         3  [ 5]
'b' ( 98)  |100011                                       23  [ 6]
'c' ( 99)  |00100                                         4  [ 5]
'd' (100)  |100100                                       24  [ 6]
'e' (101)  |00101                                         5  [ 5]
'f' (102)  |100101                                       25  [ 6]
'g' (103)  |100110                                       26  [ 6]
'h' (104)  |100111                                       27  [ 6]
'i' (105)  |00110                                         6  [ 5]
'j' (106)  |1110100                                      74  [ 7]
'k' (107)  |1110101                                      75  [ 7]
'l' (108)  |101000                                       28  [ 6]
'm' (109)  |101001                                       29  [ 6]
'n' (110)  |101010                                       2a  [ 6]
'o' (111)  |00111                                         7  [ 5]
'p' (112)  |101011                                       2b  [ 6]
'q' (113)  |1110110                                      76  [ 7]
'r' (114)  |101100                                       2c  [ 6]
's' (115)  |01000                                         8  [ 5]
't' (116)  |01001                                         9  [ 5]
'u' (117)  |101101                                       2d  [ 6]
'v' (118)  |1110111                                      77  [ 7]
'w' (119)  |1111000                                      78  [ 7]
'x' (120)  |1111001                                      79  [ 7]
'y' (121)  |1111010                                      7a  [ 7]
'z' (122)  |1111011                                      7b  [ 7]
'{' (123)  |11111111|1111110                           7ffe  [15]
'|' (124)  |11111111|100                                7fc  [11]
'}' (125)  |11111111|111101                            3ffd  [14]
'~' (126)  |11111111|11101                             1ffd  [13]
    (127)  |11111111|11111111|11111111|1100         ffffffc  [28]
    (128)  |11111111|11111110|0110                    fffe6  [20]
    (129)  |11111111|11111111|010010                 3fffd2  [22]
    (130)  |11111111|11111110|0111                    fffe7  [20]
    (131)  |11111111|11111110|1000                    fffe8  [20]
    (132)  |11111111|11111111|010011                 3fffd3  [22]
    (133)  |11111111|11111111|010100                 3fffd4  [22]
    (134)  |11111111|11111111|010101                 3fffd5  [22]
    (135)  |11111111|11111111|1011001                7fffd9  [23]
    (136)  |11111111|11111111|010110                 3fffd6  [22]
    (137)  |11111111|11111111|1011010                7fffda  [23]
    (138)  |11111111|11111111|1011011                7fffdb  [23]
    (139)  |11111111|11111111|1011100                7fffdc  [23]
    (140)  |11111111|11111111|1011101                7fffdd  [23]
    (141)  |11111111|11111111|1011110                7fffde  [23]
    (142)  |11111111|11111111|11101011               ffffeb  [24]
    (143)  |11111111|11111111|1011111                7fffdf  [23]
    (144)  |11111111|11111111|11101100               ffffec  [24]
    (145)  |11111111|11111111|11101101               ffffed  [24]
    (146)  |11111111|11111111|010111                 3fffd7  [22]
    (147)  |11111111|11111111|1100000                7fffe0  [23]
    (148)  |11111111|11111111|11101110               ffffee  [24]
    (149)  |11111111|11111111|1100001                7fffe1  [23]
    (150)  |11111111|11111111|1100010                7fffe2  [23]
    (151)  |11111111|11111111|1100011                7fffe3  [23]
    (152)  |11111111|11111111|1100100                7fffe4  [23]
    (153)  |11111111|11111110|11100                  1fffdc  [21]
    (154)  |11111111|11111111|011000                 3fffd8  [22]
    (155)  |11111111|11111111|1100101                7fffe5  [23]
    (156)  |11111111|11111111|011001                 3fffd9  [22]
    (157)  |11111111|11111111|1100110                7fffe6  [23]
    (158)  |11111111|11111111|1100111                7fffe7  [23]
    (159)  |11111111|11111111|11101111               ffffef  [24]
    (160)  |11111111|11111111|011010                 3fffda  [22]
    (161)  |11111111|11111110|11101                  1fffdd  [21]
    (162)  |11111111|11111110|1001                    fffe9  [20]
    (163)  |11111111|11111111|011011                 3fffdb  [22]
    (164)  |11111111|11111111|011100                 3fffdc  [22]
    (165)  |11111111|11111111|1101000                7fffe8  [23]
    (166)  |11111111|11111111|1101001                7fffe9  [23]
    (167)  |11111111|11111110|11110                  1fffde  [21]
    (168)  |11111111|11111111|1101010                7fffea  [23]
    (169)  |11111111|11111111|011101                 3fffdd  [22]
    (170)  |11111111|11111111|011110                 3fffde  [22]
    (171)  |11111111|11111111|11110000               fffff0  [24]
    (172)  |11111111|11111110|11111                  1fffdf  [21]
    (173)  |11111111|11111111|011111                 3fffdf  [22]
    (174)  |11111111|11111111|1101011                7fffeb  [23]
    (175)  |11111111|11111111|1101100                7fffec  [23]
    (176)  |11111111|11111111|00000                  1fffe0  [21]
    (177)  |11111111|11111111|00001                  1fffe1  [21]
    (178)  |11111111|11111111|100000                 3fffe0  [22]
    (179)  |11111111|11111111|00010                  1fffe2  [21]
    (180)  |11111111|11111111|1101101                7fffed  [23]
    (181)  |11111111|11111111|100001                 3fffe1  [22]
    (182)  |11111111|11111111|1101110                7fffee  [23]
    (183)  |11111111|11111111|1101111                7fffef  [23]
    (184)  |11111111|11111110|1010                    fffea  [20]
    (185)  |11111111|11111111|100010                 3fffe2  [22]
    (186)  |11111111|11111111|100011                 3fffe3  [22]
    (187)  |11111111|11111111|100100                 3fffe4  [22]
    (188)  |11111111|11111111|1110000                7ffff0  [23]
    (189)  |11111111|11111111|100101                 3fffe5  [22]
    (190)  |11111111|11111111|100110                 3fffe6  [22]
    (191)  |11111111|11111111|1110001                7ffff1  [23]
    (192)  |11111111|11111111|11111000|00           3ffffe0  [26]
    (193)  |11111111|11111111|11111000|01           3ffffe1  [26]
    (194)  |11111111|11111110|1011                    fffeb  [20]
    (195)  |11111111|11111110|001                     7fff1  [19]
    (196)  |11111111|11111111|100111                 3fffe7  [22]
    (197)  |11111111|11111111|1110010                7ffff2  [23]
    (198)  |11111111|11111111|101000                 3fffe8  [22]
    (199)  |11111111|11111111|11110110|0            1ffffec  [25]
    (200)  |11111111|11111111|11111000|10           3ffffe2  [26]
    (201)  |11111111|11111111|11111000|11           3ffffe3  [26]
    (202)  |11111111|11111111|11111001|00           3ffffe4  [26]
    (203)  |11111111|11111111|11111011|110          7ffffde  [27]
    (204)  |11111111|11111111|11111011|111          7ffffdf  [27]
    (205)  |11111111|11111111|11111001|01           3ffffe5  [26]
    (206)  |11111111|11111111|11110001               fffff1  [24]
    (207)  |11111111|11111111|11110110|1            1ffffed  [25]
    (208)  |11111111|11111110|010                     7fff2  [19]
    (209)  |11111111|11111111|00011                  1fffe3  [21]
    (210)  |11111111|11111111|11111001|10           3ffffe6  [26]
    (211)  |11111111|11111111|11111100|000          7ffffe0  [27]
    (212)  |11111111|11111111|11111100|001          7ffffe1  [27]
    (213)  |11111111|11111111|11111001|11           3ffffe7  [26]
    (214)  |11111111|11111111|11111100|010          7ffffe2  [27]
    (215)  |11111111|11111111|11110010               fffff2  [24]
    (216)  |11111111|11111111|00100                  1fffe4  [21]
    (217)  |11111111|11111111|00101                  1fffe5  [21]
    (218)  |11111111|11111111|11111010|00           3ffffe8  [26]
    (219)  |11111111|11111111|11111010|01           3ffffe9  [26]
    (220)  |11111111|11111111|11111111|1101         ffffffd  [28]
    (221)  |11111111|11111111|11111100|011          7ffffe3  [27]
    (222)  |11111111|11111111|11111100|100          7ffffe4  [27]
    (223)  |11111111|11111111|11111100|101          7ffffe5  [27]
    (224)  |11111111|11111110|1100                    fffec  [20]
    (225)  |11111111|11111111|11110011               fffff3  [24]
    (226)  |11111111|11111110|1101                    fffed  [20]
    (227)  |11111111|11111111|00110                  1fffe6  [21]
    (228)  |11111111|11111111|101001                 3fffe9  [22]
    (229)  |11111111|11111111|00111                  1fffe7  [21]
    (230)  |11111111|11111111|01000                  1fffe8  [21]
    (231)  |11111111|11111111|1110011                7ffff3  [23]
    (232)  |11111111|11111111|101010                 3fffea  [22]
    (233)  |11111111|11111111|101011                 3fffeb  [22]
    (234)  |11111111|11111111|11110111|0            1ffffee  [25]
    (235)  |11111111|11111111|11110111|1            1ffffef  [25]
    (236)  |11111111|11111111|11110100               fffff4  [24]
    (237)  |11111111|11111111|11110101               fffff5  [24]
    (238)  |11111111|11111111|11111010|10           3ffffea  [26]
    (239)  |11111111|11111111|1110100                7ffff4  [23]
    (240)  |11111111|11111111|11111010|11           3ffffeb  [26]
    (241)  |11111111|11111111|11111100|110          7ffffe6  [27]
    (242)  |11111111|11111111|11111011|00           3ffffec  [26]
    (243)  |11111111|11111111|11111011|01           3ffffed  [26]
    (244)  |11111111|11111111|11111100|111          7ffffe7  [27]
    (245)  |11111111|11111111|11111101|000          7ffffe8  [27]
    (246)  |11111111|11111111|11111101|001          7ffffe9  [27]
    (247)  |11111111|11111111|11111101|010          7ffffea  [27]
    (248)  |11111111|11111111|11111101|011          7ffffeb  [27]
    (249)  |11111111|11111111|11111111|1110         ffffffe  [28]
    (250)  |11111111|11111111|11111101|100          7ffffec  [27]
    (251)  |11111111|11111111|11111101|101          7ffffed  [27]
    (252)  |11111111|11111111|11111101|110          7ffffee  [27]
    (253)  |11111111|11111111|11111101|111          7ffffef  [27]
    (254)  |11111111|11111111|11111110|000          7fffff0  [27]
    (255)  |11111111|11111111|11111011|10           3ffffee  [26]
EOS (256)  |11111111|11111111|11111111|111111      3fffffff  [30]
]]></artwork>
            </figure>
        </section>


        <section title="例" anchor="examples">
            <t>
                A number of examples are worked through here, covering integer
                encoding, header field representation, and the encoding of whole
                lists of header fields, for both requests and responses, and
                with and without Huffman coding.
            </t>

            <section title="Integer Representation Examples"
                anchor="integer.representation.examples">
                <t>
                    This section shows the representation of integer values in
                    details (see <xref target="integer.representation"/>).
                </t>
                <section title="Example 1: Encoding 10 Using a 5-bit Prefix"
                    anchor="integer.representation.example1">
                    <t>
                        The value 10 is to be encoded with a 5-bit prefix.
                        <list style="symbols">
                            <t>
                                10 is less than 31 (2<x:sup>5</x:sup> - 1) and
                                is represented using the 5-bit prefix.
                            </t>
                        </list>
                    </t>
                    <figure>
                        <artwork><![CDATA[
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| X | X | X | 0 | 1 | 0 | 1 | 0 |   10 stored on 5 bits
+---+---+---+---+---+---+---+---+
]]></artwork>
                    </figure>
                </section>

                <section title="Example 2: Encoding 1337 Using a 5-bit Prefix"
                    anchor="integer.representation.example2">
                    <t>
                        The value I=1337 is to be encoded with a 5-bit prefix.
                        <list>
                            <t>
                                1337 is greater than 31 (2<x:sup>5</x:sup> - 1).
                            </t>
                            <t>
                                <list>
                                    <t>The 5-bit prefix is filled with its max
                                    value (31).</t>
                                </list>
                            </t>
                            <t>I = 1337 - (2<x:sup>5</x:sup> - 1) = 1306.</t>
                            <t>
                                <list>
                                    <t>I (1306) is greater than or equal to 128,
                                    the while loop body executes:</t>
                                    <t>
                                        <list>
                                            <t>I % 128 == 26</t>
                                            <t>26 + 128 == 154</t>
                                            <t>154 is encoded in 8 bits as:
                                            10011010</t>
                                            <t>I is set to 10 (1306 / 128 ==
                                            10)</t>
                                            <t>I is no longer greater than or
                                            equal to 128, the while loop
                                            terminates.</t>
                                        </list>
                                    </t>
                                    <t>
                                        I, now 10, is encoded on 8 bits as:
                                        00001010.
                                    </t>
                                </list>
                            </t>

                            <t>The process ends.</t>
                        </list>

                    </t>
                    <figure>
                        <artwork><![CDATA[
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| X | X | X | 1 | 1 | 1 | 1 | 1 |  Prefix = 31, I = 1306
| 1 | 0 | 0 | 1 | 1 | 0 | 1 | 0 |  1306>=128, encode(154), I=1306/128
| 0 | 0 | 0 | 0 | 1 | 0 | 1 | 0 |  10<128, encode(10), done
+---+---+---+---+---+---+---+---+
]]></artwork>
                    </figure>
                </section>

                <section title="Example 3: Encoding 42 Starting at an Octet Boundary"
                    anchor="integer.representation.example3">
                    <t>
                        The value 42 is to be encoded starting at an
                        octet-boundary. This implies that a 8-bit prefix is
                        used.
                        <list style="symbols">
                            <t>
                                42 is less than 255 (2<x:sup>8</x:sup> - 1) and
                                is represented using the 8-bit prefix.
                            </t>
                        </list>
                    </t>
                    <figure>
                        <artwork><![CDATA[
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 0 | 1 | 0 | 1 | 0 | 1 | 0 |   42 stored on 8 bits
+---+---+---+---+---+---+---+---+
]]></artwork>
                    </figure>
                </section>
            </section>

<!-- example-start -->
<section title="Header Field Representation Examples"
    anchor="header.field.representation.examples">
    <t>
        This section shows several independent representation examples.
    </t>
    <section title="Literal Header Field with Indexing">
        <t>
            The header field representation uses a literal name and a literal
            value. The header field is added to the dynamic table.
        </t>
        <t>
            <figure>
                <preamble>Header list to encode:</preamble>
                <artwork>
<![CDATA[custom-key: custom-header]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Hex dump of encoded data:</preamble>
                <artwork>
<![CDATA[400a 6375 7374 6f6d 2d6b 6579 0d63 7573 | @.custom-key.cus
746f 6d2d 6865 6164 6572                | tom-header]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoding process:</preamble>
                <artwork>
<![CDATA[40                                      | == Literal indexed ==
0a                                      |   Literal name (len = 10)
6375 7374 6f6d 2d6b 6579                | custom-key
0d                                      |   Literal value (len = 13)
6375 7374 6f6d 2d68 6561 6465 72        | custom-header
                                        | -> custom-key: custom-head\
                                        |   er]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Dynamic Table (after decoding):</preamble>
                <artwork>
<![CDATA[[  1] (s =  55) custom-key: custom-header
      Table size:  55]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoded header list:</preamble>
                <artwork>
<![CDATA[custom-key: custom-header]]></artwork>
            </figure>
        </t>
    </section>

    <section title="Literal Header Field without Indexing">
        <t>
            The header field representation uses an indexed name and a literal
            value. The header field is not added to the dynamic table.
        </t>
        <t>
            <figure>
                <preamble>Header list to encode:</preamble>
                <artwork>
<![CDATA[:path: /sample/path]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Hex dump of encoded data:</preamble>
                <artwork>
<![CDATA[040c 2f73 616d 706c 652f 7061 7468      | ../sample/path]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoding process:</preamble>
                <artwork>
<![CDATA[04                                      | == Literal not indexed ==
                                        |   Indexed name (idx = 4)
                                        |     :path
0c                                      |   Literal value (len = 12)
2f73 616d 706c 652f 7061 7468           | /sample/path
                                        | -> :path: /sample/path]]></artwork>
            </figure>
        </t>
        <t>
          Dynamic table (after decoding): empty.
        </t>
        <t>
            <figure>
                <preamble>Decoded header list:</preamble>
                <artwork>
<![CDATA[:path: /sample/path]]></artwork>
            </figure>
        </t>
    </section>

    <section title="Literal Header Field never Indexed">
        <t>
            The header field representation uses a literal name and a literal
            value. The header field is not added to the dynamic table, and must
            use the same representation if re-encoded by an intermediary.
        </t>
        <t>
            <figure>
                <preamble>Header list to encode:</preamble>
                <artwork>
<![CDATA[password: secret]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Hex dump of encoded data:</preamble>
                <artwork>
<![CDATA[1008 7061 7373 776f 7264 0673 6563 7265 | ..password.secre
74                                      | t]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoding process:</preamble>
                <artwork>
<![CDATA[10                                      | == Literal never indexed ==
08                                      |   Literal name (len = 8)
7061 7373 776f 7264                     | password
06                                      |   Literal value (len = 6)
7365 6372 6574                          | secret
                                        | -> password: secret]]></artwork>
            </figure>
        </t>
        <t>
          Dynamic table (after decoding): empty.
        </t>
        <t>
            <figure>
                <preamble>Decoded header list:</preamble>
                <artwork>
<![CDATA[password: secret]]></artwork>
            </figure>
        </t>
    </section>

    <section title="Indexed Header Field">
        <t>
            The header field representation uses an indexed header field, from
            the static table.
        </t>
        <t>
            <figure>
                <preamble>Header list to encode:</preamble>
                <artwork>
<![CDATA[:method: GET]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Hex dump of encoded data:</preamble>
                <artwork>
<![CDATA[82                                      | .]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoding process:</preamble>
                <artwork>
<![CDATA[82                                      | == Indexed - Add ==
                                        |   idx = 2
                                        | -> :method: GET]]></artwork>
            </figure>
        </t>
        <t>
          Dynamic table (after decoding): empty.
        </t>
        <t>
            <figure>
                <preamble>Decoded header list:</preamble>
                <artwork>
<![CDATA[:method: GET]]></artwork>
            </figure>
        </t>
    </section>

</section>
<section title="Request Examples without Huffman Coding"
    anchor="request.examples.without.huffman.coding">
    <t>
        This section shows several consecutive header lists, corresponding to
        HTTP requests, on the same connection.
    </t>
    <section title="First Request">
        <t>
            <figure>
                <preamble>Header list to encode:</preamble>
                <artwork>
<![CDATA[:method: GET
:scheme: http
:path: /
:authority: www.example.com]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Hex dump of encoded data:</preamble>
                <artwork>
<![CDATA[8286 8441 0f77 7777 2e65 7861 6d70 6c65 | ...A.www.example
2e63 6f6d                               | .com]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoding process:</preamble>
                <artwork>
<![CDATA[82                                      | == Indexed - Add ==
                                        |   idx = 2
                                        | -> :method: GET
86                                      | == Indexed - Add ==
                                        |   idx = 6
                                        | -> :scheme: http
84                                      | == Indexed - Add ==
                                        |   idx = 4
                                        | -> :path: /
41                                      | == Literal indexed ==
                                        |   Indexed name (idx = 1)
                                        |     :authority
0f                                      |   Literal value (len = 15)
7777 772e 6578 616d 706c 652e 636f 6d   | www.example.com
                                        | -> :authority: www.example\
                                        |   .com]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Dynamic Table (after decoding):</preamble>
                <artwork>
<![CDATA[[  1] (s =  57) :authority: www.example.com
      Table size:  57]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoded header list:</preamble>
                <artwork>
<![CDATA[:method: GET
:scheme: http
:path: /
:authority: www.example.com]]></artwork>
            </figure>
        </t>
    </section>

    <section title="Second Request">
        <t>
            <figure>
                <preamble>Header list to encode:</preamble>
                <artwork>
<![CDATA[:method: GET
:scheme: http
:path: /
:authority: www.example.com
cache-control: no-cache]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Hex dump of encoded data:</preamble>
                <artwork>
<![CDATA[8286 84be 5808 6e6f 2d63 6163 6865      | ....X.no-cache]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoding process:</preamble>
                <artwork>
<![CDATA[82                                      | == Indexed - Add ==
                                        |   idx = 2
                                        | -> :method: GET
86                                      | == Indexed - Add ==
                                        |   idx = 6
                                        | -> :scheme: http
84                                      | == Indexed - Add ==
                                        |   idx = 4
                                        | -> :path: /
be                                      | == Indexed - Add ==
                                        |   idx = 62
                                        | -> :authority: www.example\
                                        |   .com
58                                      | == Literal indexed ==
                                        |   Indexed name (idx = 24)
                                        |     cache-control
08                                      |   Literal value (len = 8)
6e6f 2d63 6163 6865                     | no-cache
                                        | -> cache-control: no-cache]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Dynamic Table (after decoding):</preamble>
                <artwork>
<![CDATA[[  1] (s =  53) cache-control: no-cache
[  2] (s =  57) :authority: www.example.com
      Table size: 110]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoded header list:</preamble>
                <artwork>
<![CDATA[:method: GET
:scheme: http
:path: /
:authority: www.example.com
cache-control: no-cache]]></artwork>
            </figure>
        </t>
    </section>

    <section title="Third Request">
        <t>
            <figure>
                <preamble>Header list to encode:</preamble>
                <artwork>
<![CDATA[:method: GET
:scheme: https
:path: /index.html
:authority: www.example.com
custom-key: custom-value]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Hex dump of encoded data:</preamble>
                <artwork>
<![CDATA[8287 85bf 400a 6375 7374 6f6d 2d6b 6579 | ....@.custom-key
0c63 7573 746f 6d2d 7661 6c75 65        | .custom-value]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoding process:</preamble>
                <artwork>
<![CDATA[82                                      | == Indexed - Add ==
                                        |   idx = 2
                                        | -> :method: GET
87                                      | == Indexed - Add ==
                                        |   idx = 7
                                        | -> :scheme: https
85                                      | == Indexed - Add ==
                                        |   idx = 5
                                        | -> :path: /index.html
bf                                      | == Indexed - Add ==
                                        |   idx = 63
                                        | -> :authority: www.example\
                                        |   .com
40                                      | == Literal indexed ==
0a                                      |   Literal name (len = 10)
6375 7374 6f6d 2d6b 6579                | custom-key
0c                                      |   Literal value (len = 12)
6375 7374 6f6d 2d76 616c 7565           | custom-value
                                        | -> custom-key: custom-valu\
                                        |   e]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Dynamic Table (after decoding):</preamble>
                <artwork>
<![CDATA[[  1] (s =  54) custom-key: custom-value
[  2] (s =  53) cache-control: no-cache
[  3] (s =  57) :authority: www.example.com
      Table size: 164]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoded header list:</preamble>
                <artwork>
<![CDATA[:method: GET
:scheme: https
:path: /index.html
:authority: www.example.com
custom-key: custom-value]]></artwork>
            </figure>
        </t>
    </section>

</section>
<section title="Request Examples with Huffman Coding"
    anchor="request.examples.with.huffman.coding">
    <t>
        This section shows the same examples as the previous section, but using
        Huffman encoding for the literal values.
    </t>
    <section title="First Request">
        <t>
            <figure>
                <preamble>Header list to encode:</preamble>
                <artwork>
<![CDATA[:method: GET
:scheme: http
:path: /
:authority: www.example.com]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Hex dump of encoded data:</preamble>
                <artwork>
<![CDATA[8286 8441 8cf1 e3c2 e5f2 3a6b a0ab 90f4 | ...A......:k....
ff                                      | .]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoding process:</preamble>
                <artwork>
<![CDATA[82                                      | == Indexed - Add ==
                                        |   idx = 2
                                        | -> :method: GET
86                                      | == Indexed - Add ==
                                        |   idx = 6
                                        | -> :scheme: http
84                                      | == Indexed - Add ==
                                        |   idx = 4
                                        | -> :path: /
41                                      | == Literal indexed ==
                                        |   Indexed name (idx = 1)
                                        |     :authority
8c                                      |   Literal value (len = 12)
                                        |     Huffman encoded:
f1e3 c2e5 f23a 6ba0 ab90 f4ff           | .....:k.....
                                        |     Decoded:
                                        | www.example.com
                                        | -> :authority: www.example\
                                        |   .com]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Dynamic Table (after decoding):</preamble>
                <artwork>
<![CDATA[[  1] (s =  57) :authority: www.example.com
      Table size:  57]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoded header list:</preamble>
                <artwork>
<![CDATA[:method: GET
:scheme: http
:path: /
:authority: www.example.com]]></artwork>
            </figure>
        </t>
    </section>

    <section title="Second Request">
        <t>
            <figure>
                <preamble>Header list to encode:</preamble>
                <artwork>
<![CDATA[:method: GET
:scheme: http
:path: /
:authority: www.example.com
cache-control: no-cache]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Hex dump of encoded data:</preamble>
                <artwork>
<![CDATA[8286 84be 5886 a8eb 1064 9cbf           | ....X....d..]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoding process:</preamble>
                <artwork>
<![CDATA[82                                      | == Indexed - Add ==
                                        |   idx = 2
                                        | -> :method: GET
86                                      | == Indexed - Add ==
                                        |   idx = 6
                                        | -> :scheme: http
84                                      | == Indexed - Add ==
                                        |   idx = 4
                                        | -> :path: /
be                                      | == Indexed - Add ==
                                        |   idx = 62
                                        | -> :authority: www.example\
                                        |   .com
58                                      | == Literal indexed ==
                                        |   Indexed name (idx = 24)
                                        |     cache-control
86                                      |   Literal value (len = 6)
                                        |     Huffman encoded:
a8eb 1064 9cbf                          | ...d..
                                        |     Decoded:
                                        | no-cache
                                        | -> cache-control: no-cache]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Dynamic Table (after decoding):</preamble>
                <artwork>
<![CDATA[[  1] (s =  53) cache-control: no-cache
[  2] (s =  57) :authority: www.example.com
      Table size: 110]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoded header list:</preamble>
                <artwork>
<![CDATA[:method: GET
:scheme: http
:path: /
:authority: www.example.com
cache-control: no-cache]]></artwork>
            </figure>
        </t>
    </section>

    <section title="Third Request">
        <t>
            <figure>
                <preamble>Header list to encode:</preamble>
                <artwork>
<![CDATA[:method: GET
:scheme: https
:path: /index.html
:authority: www.example.com
custom-key: custom-value]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Hex dump of encoded data:</preamble>
                <artwork>
<![CDATA[8287 85bf 4088 25a8 49e9 5ba9 7d7f 8925 | ....@.%.I.[.}..%
a849 e95b b8e8 b4bf                     | .I.[....]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoding process:</preamble>
                <artwork>
<![CDATA[82                                      | == Indexed - Add ==
                                        |   idx = 2
                                        | -> :method: GET
87                                      | == Indexed - Add ==
                                        |   idx = 7
                                        | -> :scheme: https
85                                      | == Indexed - Add ==
                                        |   idx = 5
                                        | -> :path: /index.html
bf                                      | == Indexed - Add ==
                                        |   idx = 63
                                        | -> :authority: www.example\
                                        |   .com
40                                      | == Literal indexed ==
88                                      |   Literal name (len = 8)
                                        |     Huffman encoded:
25a8 49e9 5ba9 7d7f                     | %.I.[.}.
                                        |     Decoded:
                                        | custom-key
89                                      |   Literal value (len = 9)
                                        |     Huffman encoded:
25a8 49e9 5bb8 e8b4 bf                  | %.I.[....
                                        |     Decoded:
                                        | custom-value
                                        | -> custom-key: custom-valu\
                                        |   e]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Dynamic Table (after decoding):</preamble>
                <artwork>
<![CDATA[[  1] (s =  54) custom-key: custom-value
[  2] (s =  53) cache-control: no-cache
[  3] (s =  57) :authority: www.example.com
      Table size: 164]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoded header list:</preamble>
                <artwork>
<![CDATA[:method: GET
:scheme: https
:path: /index.html
:authority: www.example.com
custom-key: custom-value]]></artwork>
            </figure>
        </t>
    </section>

</section>
<section title="Response Examples without Huffman Coding"
    anchor="response.examples.without.huffman.coding">
    <t>
        This section shows several consecutive header lists, corresponding to
        HTTP responses, on the same connection. The HTTP/2 setting parameter
        SETTINGS_HEADER_TABLE_SIZE is set to the value of 256 octets, causing
        some evictions to occur.
    </t>
    <section title="First Response">
        <t>
            <figure>
                <preamble>Header list to encode:</preamble>
                <artwork>
<![CDATA[:status: 302
cache-control: private
date: Mon, 21 Oct 2013 20:13:21 GMT
location: https://www.example.com]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Hex dump of encoded data:</preamble>
                <artwork>
<![CDATA[4803 3330 3258 0770 7269 7661 7465 611d | H.302X.privatea.
4d6f 6e2c 2032 3120 4f63 7420 3230 3133 | Mon, 21 Oct 2013
2032 303a 3133 3a32 3120 474d 546e 1768 |  20:13:21 GMTn.h
7474 7073 3a2f 2f77 7777 2e65 7861 6d70 | ttps://www.examp
6c65 2e63 6f6d                          | le.com]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoding process:</preamble>
                <artwork>
<![CDATA[48                                      | == Literal indexed ==
                                        |   Indexed name (idx = 8)
                                        |     :status
03                                      |   Literal value (len = 3)
3330 32                                 | 302
                                        | -> :status: 302
58                                      | == Literal indexed ==
                                        |   Indexed name (idx = 24)
                                        |     cache-control
07                                      |   Literal value (len = 7)
7072 6976 6174 65                       | private
                                        | -> cache-control: private
61                                      | == Literal indexed ==
                                        |   Indexed name (idx = 33)
                                        |     date
1d                                      |   Literal value (len = 29)
4d6f 6e2c 2032 3120 4f63 7420 3230 3133 | Mon, 21 Oct 2013
2032 303a 3133 3a32 3120 474d 54        |  20:13:21 GMT
                                        | -> date: Mon, 21 Oct 2013 \
                                        |   20:13:21 GMT
6e                                      | == Literal indexed ==
                                        |   Indexed name (idx = 46)
                                        |     location
17                                      |   Literal value (len = 23)
6874 7470 733a 2f2f 7777 772e 6578 616d | https://www.exam
706c 652e 636f 6d                       | ple.com
                                        | -> location: https://www.e\
                                        |   xample.com]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Dynamic Table (after decoding):</preamble>
                <artwork>
<![CDATA[[  1] (s =  63) location: https://www.example.com
[  2] (s =  65) date: Mon, 21 Oct 2013 20:13:21 GMT
[  3] (s =  52) cache-control: private
[  4] (s =  42) :status: 302
      Table size: 222]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoded header list:</preamble>
                <artwork>
<![CDATA[:status: 302
cache-control: private
date: Mon, 21 Oct 2013 20:13:21 GMT
location: https://www.example.com]]></artwork>
            </figure>
        </t>
    </section>

    <section title="Second Response">
        <t>
            The (":status", "302") header field is evicted from the dynamic table
            to free space to allow adding the (":status", "307") header field.
        </t>
        <t>
            <figure>
                <preamble>Header list to encode:</preamble>
                <artwork>
<![CDATA[:status: 307
cache-control: private
date: Mon, 21 Oct 2013 20:13:21 GMT
location: https://www.example.com]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Hex dump of encoded data:</preamble>
                <artwork>
<![CDATA[4803 3330 37c1 c0bf                     | H.307...]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoding process:</preamble>
                <artwork>
<![CDATA[48                                      | == Literal indexed ==
                                        |   Indexed name (idx = 8)
                                        |     :status
03                                      |   Literal value (len = 3)
3330 37                                 | 307
                                        | - evict: :status: 302
                                        | -> :status: 307
c1                                      | == Indexed - Add ==
                                        |   idx = 65
                                        | -> cache-control: private
c0                                      | == Indexed - Add ==
                                        |   idx = 64
                                        | -> date: Mon, 21 Oct 2013 \
                                        |   20:13:21 GMT
bf                                      | == Indexed - Add ==
                                        |   idx = 63
                                        | -> location: https://www.e\
                                        |   xample.com]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Dynamic Table (after decoding):</preamble>
                <artwork>
<![CDATA[[  1] (s =  42) :status: 307
[  2] (s =  63) location: https://www.example.com
[  3] (s =  65) date: Mon, 21 Oct 2013 20:13:21 GMT
[  4] (s =  52) cache-control: private
      Table size: 222]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoded header list:</preamble>
                <artwork>
<![CDATA[:status: 307
cache-control: private
date: Mon, 21 Oct 2013 20:13:21 GMT
location: https://www.example.com]]></artwork>
            </figure>
        </t>
    </section>

    <section title="Third Response">
        <t>
            Several header fields are evicted from the dynamic table during the
            processing of this header list.
        </t>
        <t>
            <figure>
                <preamble>Header list to encode:</preamble>
                <artwork>
<![CDATA[:status: 200
cache-control: private
date: Mon, 21 Oct 2013 20:13:22 GMT
location: https://www.example.com
content-encoding: gzip
set-cookie: foo=ASDJKHQKBZXOQWEOPIUAXQWEOIU; max-age=3600; version=1]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Hex dump of encoded data:</preamble>
                <artwork>
<![CDATA[88c1 611d 4d6f 6e2c 2032 3120 4f63 7420 | ..a.Mon, 21 Oct
3230 3133 2032 303a 3133 3a32 3220 474d | 2013 20:13:22 GM
54c0 5a04 677a 6970 7738 666f 6f3d 4153 | T.Z.gzipw8foo=AS
444a 4b48 514b 425a 584f 5157 454f 5049 | DJKHQKBZXOQWEOPI
5541 5851 5745 4f49 553b 206d 6178 2d61 | UAXQWEOIU; max-a
6765 3d33 3630 303b 2076 6572 7369 6f6e | ge=3600; version
3d31                                    | =1]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoding process:</preamble>
                <artwork>
<![CDATA[88                                      | == Indexed - Add ==
                                        |   idx = 8
                                        | -> :status: 200
c1                                      | == Indexed - Add ==
                                        |   idx = 65
                                        | -> cache-control: private
61                                      | == Literal indexed ==
                                        |   Indexed name (idx = 33)
                                        |     date
1d                                      |   Literal value (len = 29)
4d6f 6e2c 2032 3120 4f63 7420 3230 3133 | Mon, 21 Oct 2013
2032 303a 3133 3a32 3220 474d 54        |  20:13:22 GMT
                                        | - evict: cache-control: pr\
                                        |   ivate
                                        | -> date: Mon, 21 Oct 2013 \
                                        |   20:13:22 GMT
c0                                      | == Indexed - Add ==
                                        |   idx = 64
                                        | -> location: https://www.e\
                                        |   xample.com
5a                                      | == Literal indexed ==
                                        |   Indexed name (idx = 26)
                                        |     content-encoding
04                                      |   Literal value (len = 4)
677a 6970                               | gzip
                                        | - evict: date: Mon, 21 Oct\
                                        |    2013 20:13:21 GMT
                                        | -> content-encoding: gzip
77                                      | == Literal indexed ==
                                        |   Indexed name (idx = 55)
                                        |     set-cookie
38                                      |   Literal value (len = 56)
666f 6f3d 4153 444a 4b48 514b 425a 584f | foo=ASDJKHQKBZXO
5157 454f 5049 5541 5851 5745 4f49 553b | QWEOPIUAXQWEOIU;
206d 6178 2d61 6765 3d33 3630 303b 2076 |  max-age=3600; v
6572 7369 6f6e 3d31                     | ersion=1
                                        | - evict: location: https:/\
                                        |   /www.example.com
                                        | - evict: :status: 307
                                        | -> set-cookie: foo=ASDJKHQ\
                                        |   KBZXOQWEOPIUAXQWEOIU; ma\
                                        |   x-age=3600; version=1]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Dynamic Table (after decoding):</preamble>
                <artwork>
<![CDATA[[  1] (s =  98) set-cookie: foo=ASDJKHQKBZXOQWEOPIUAXQWEOIU; max-age\
                 =3600; version=1
[  2] (s =  52) content-encoding: gzip
[  3] (s =  65) date: Mon, 21 Oct 2013 20:13:22 GMT
      Table size: 215]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoded header list:</preamble>
                <artwork>
<![CDATA[:status: 200
cache-control: private
date: Mon, 21 Oct 2013 20:13:22 GMT
location: https://www.example.com
content-encoding: gzip
set-cookie: foo=ASDJKHQKBZXOQWEOPIUAXQWEOIU; max-age=3600; version=1]]></artwork>
            </figure>
        </t>
    </section>

</section>
<section title="Response Examples with Huffman Coding"
    anchor="response.examples.with.huffman.coding">
    <t>
        This section shows the same examples as the previous section, but using
        Huffman encoding for the literal values. The HTTP/2 setting parameter
        SETTINGS_HEADER_TABLE_SIZE is set to the value of 256 octets, causing
        some evictions to occur. The eviction mechanism uses the length of the
        decoded literal values, so the same evictions occurs as in the previous
        section.
    </t>
    <section title="First Response">
        <t>
            <figure>
                <preamble>Header list to encode:</preamble>
                <artwork>
<![CDATA[:status: 302
cache-control: private
date: Mon, 21 Oct 2013 20:13:21 GMT
location: https://www.example.com]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Hex dump of encoded data:</preamble>
                <artwork>
<![CDATA[4882 6402 5885 aec3 771a 4b61 96d0 7abe | H.d.X...w.Ka..z.
9410 54d4 44a8 2005 9504 0b81 66e0 82a6 | ..T.D. .....f...
2d1b ff6e 919d 29ad 1718 63c7 8f0b 97c8 | -..n..)...c.....
e9ae 82ae 43d3                          | ....C.]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoding process:</preamble>
                <artwork>
<![CDATA[48                                      | == Literal indexed ==
                                        |   Indexed name (idx = 8)
                                        |     :status
82                                      |   Literal value (len = 2)
                                        |     Huffman encoded:
6402                                    | d.
                                        |     Decoded:
                                        | 302
                                        | -> :status: 302
58                                      | == Literal indexed ==
                                        |   Indexed name (idx = 24)
                                        |     cache-control
85                                      |   Literal value (len = 5)
                                        |     Huffman encoded:
aec3 771a 4b                            | ..w.K
                                        |     Decoded:
                                        | private
                                        | -> cache-control: private
61                                      | == Literal indexed ==
                                        |   Indexed name (idx = 33)
                                        |     date
96                                      |   Literal value (len = 22)
                                        |     Huffman encoded:
d07a be94 1054 d444 a820 0595 040b 8166 | .z...T.D. .....f
e082 a62d 1bff                          | ...-..
                                        |     Decoded:
                                        | Mon, 21 Oct 2013 20:13:21 \
                                        | GMT
                                        | -> date: Mon, 21 Oct 2013 \
                                        |   20:13:21 GMT
6e                                      | == Literal indexed ==
                                        |   Indexed name (idx = 46)
                                        |     location
91                                      |   Literal value (len = 17)
                                        |     Huffman encoded:
9d29 ad17 1863 c78f 0b97 c8e9 ae82 ae43 | .)...c.........C
d3                                      | .
                                        |     Decoded:
                                        | https://www.example.com
                                        | -> location: https://www.e\
                                        |   xample.com]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Dynamic Table (after decoding):</preamble>
                <artwork>
<![CDATA[[  1] (s =  63) location: https://www.example.com
[  2] (s =  65) date: Mon, 21 Oct 2013 20:13:21 GMT
[  3] (s =  52) cache-control: private
[  4] (s =  42) :status: 302
      Table size: 222]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoded header list:</preamble>
                <artwork>
<![CDATA[:status: 302
cache-control: private
date: Mon, 21 Oct 2013 20:13:21 GMT
location: https://www.example.com]]></artwork>
            </figure>
        </t>
    </section>

    <section title="Second Response">
        <t>
            The (":status", "302") header field is evicted from the dynamic table
            to free space to allow adding the (":status", "307") header field.
        </t>
        <t>
            <figure>
                <preamble>Header list to encode:</preamble>
                <artwork>
<![CDATA[:status: 307
cache-control: private
date: Mon, 21 Oct 2013 20:13:21 GMT
location: https://www.example.com]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Hex dump of encoded data:</preamble>
                <artwork>
<![CDATA[4883 640e ffc1 c0bf                     | H.d.....]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoding process:</preamble>
                <artwork>
<![CDATA[48                                      | == Literal indexed ==
                                        |   Indexed name (idx = 8)
                                        |     :status
83                                      |   Literal value (len = 3)
                                        |     Huffman encoded:
640e ff                                 | d..
                                        |     Decoded:
                                        | 307
                                        | - evict: :status: 302
                                        | -> :status: 307
c1                                      | == Indexed - Add ==
                                        |   idx = 65
                                        | -> cache-control: private
c0                                      | == Indexed - Add ==
                                        |   idx = 64
                                        | -> date: Mon, 21 Oct 2013 \
                                        |   20:13:21 GMT
bf                                      | == Indexed - Add ==
                                        |   idx = 63
                                        | -> location: https://www.e\
                                        |   xample.com]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Dynamic Table (after decoding):</preamble>
                <artwork>
<![CDATA[[  1] (s =  42) :status: 307
[  2] (s =  63) location: https://www.example.com
[  3] (s =  65) date: Mon, 21 Oct 2013 20:13:21 GMT
[  4] (s =  52) cache-control: private
      Table size: 222]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoded header list:</preamble>
                <artwork>
<![CDATA[:status: 307
cache-control: private
date: Mon, 21 Oct 2013 20:13:21 GMT
location: https://www.example.com]]></artwork>
            </figure>
        </t>
    </section>

    <section title="Third Response">
        <t>
            Several header fields are evicted from the dynamic table during the
            processing of this header list.
        </t>
        <t>
            <figure>
                <preamble>Header list to encode:</preamble>
                <artwork>
<![CDATA[:status: 200
cache-control: private
date: Mon, 21 Oct 2013 20:13:22 GMT
location: https://www.example.com
content-encoding: gzip
set-cookie: foo=ASDJKHQKBZXOQWEOPIUAXQWEOIU; max-age=3600; version=1]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Hex dump of encoded data:</preamble>
                <artwork>
<![CDATA[88c1 6196 d07a be94 1054 d444 a820 0595 | ..a..z...T.D. ..
040b 8166 e084 a62d 1bff c05a 839b d9ab | ...f...-...Z....
77ad 94e7 821d d7f2 e6c7 b335 dfdf cd5b | w..........5...[
3960 d5af 2708 7f36 72c1 ab27 0fb5 291f | 9`..'..6r..'..).
9587 3160 65c0 03ed 4ee5 b106 3d50 07   | ..1`e...N...=P.]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoding process:</preamble>
                <artwork>
<![CDATA[88                                      | == Indexed - Add ==
                                        |   idx = 8
                                        | -> :status: 200
c1                                      | == Indexed - Add ==
                                        |   idx = 65
                                        | -> cache-control: private
61                                      | == Literal indexed ==
                                        |   Indexed name (idx = 33)
                                        |     date
96                                      |   Literal value (len = 22)
                                        |     Huffman encoded:
d07a be94 1054 d444 a820 0595 040b 8166 | .z...T.D. .....f
e084 a62d 1bff                          | ...-..
                                        |     Decoded:
                                        | Mon, 21 Oct 2013 20:13:22 \
                                        | GMT
                                        | - evict: cache-control: pr\
                                        |   ivate
                                        | -> date: Mon, 21 Oct 2013 \
                                        |   20:13:22 GMT
c0                                      | == Indexed - Add ==
                                        |   idx = 64
                                        | -> location: https://www.e\
                                        |   xample.com
5a                                      | == Literal indexed ==
                                        |   Indexed name (idx = 26)
                                        |     content-encoding
83                                      |   Literal value (len = 3)
                                        |     Huffman encoded:
9bd9 ab                                 | ...
                                        |     Decoded:
                                        | gzip
                                        | - evict: date: Mon, 21 Oct\
                                        |    2013 20:13:21 GMT
                                        | -> content-encoding: gzip
77                                      | == Literal indexed ==
                                        |   Indexed name (idx = 55)
                                        |     set-cookie
ad                                      |   Literal value (len = 45)
                                        |     Huffman encoded:
94e7 821d d7f2 e6c7 b335 dfdf cd5b 3960 | .........5...[9`
d5af 2708 7f36 72c1 ab27 0fb5 291f 9587 | ..'..6r..'..)...
3160 65c0 03ed 4ee5 b106 3d50 07        | 1`e...N...=P.
                                        |     Decoded:
                                        | foo=ASDJKHQKBZXOQWEOPIUAXQ\
                                        | WEOIU; max-age=3600; versi\
                                        | on=1
                                        | - evict: location: https:/\
                                        |   /www.example.com
                                        | - evict: :status: 307
                                        | -> set-cookie: foo=ASDJKHQ\
                                        |   KBZXOQWEOPIUAXQWEOIU; ma\
                                        |   x-age=3600; version=1]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Dynamic Table (after decoding):</preamble>
                <artwork>
<![CDATA[[  1] (s =  98) set-cookie: foo=ASDJKHQKBZXOQWEOPIUAXQWEOIU; max-age\
                 =3600; version=1
[  2] (s =  52) content-encoding: gzip
[  3] (s =  65) date: Mon, 21 Oct 2013 20:13:22 GMT
      Table size: 215]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoded header list:</preamble>
                <artwork>
<![CDATA[:status: 200
cache-control: private
date: Mon, 21 Oct 2013 20:13:22 GMT
location: https://www.example.com
content-encoding: gzip
set-cookie: foo=ASDJKHQKBZXOQWEOPIUAXQWEOIU; max-age=3600; version=1]]></artwork>
            </figure>
        </t>
    </section>

</section>
<!-- example-end -->

        </section>

        <section title="変更点 (公開前に RFC 編集者が削除すること)">
            <section title="draft-ietf-httpbis-header-compression-09 からの変更点"
                anchor="changes.since.draft-ietf-httpbis-header-compression-09">
                <t><list style="symbols">
                    <t>
                        ヘッダテーブルを動的テーブルにリネーム。
                    </t>
                    <t>
                        整数表現の更新。
                    </t>
                    <t>
                        編集上の修正。
                    </t>
                </list></t>
            </section>

            <section title="draft-ietf-httpbis-header-compression-08 からの変更点"
                anchor="changes.since.draft-ietf-httpbis-header-compression-08">
                <t><list style="symbols">
                    <t>
                        リファレンスセットの削除。
                    </t>
                    <t>
                        ヘッダ排出の削除。
                    </t>
                    <t>
                        SETTINGS_HEADER_TABLE_SIZE パラメータの幾つかの明示的な扱いの
                        変更。
                    </t>
                    <t>
                        ヘッダセットをヘッダリストにして、強制的に整列されるよう変更。
                    </t>
                    <t>
                        例の更新。
                    </t>
                    <t>
                        ヘッダテーブルと静的テーブルの場所の交換。
                    </t>
                </list></t>
            </section>
            <section title="draft-ietf-httpbis-header-compression-07 からの変更点"
                anchor="changes.since.draft-ietf-httpbis-header-compression-07">
                <t><list style="symbols">
                    <t>
                        インデックス値 0 の古い記述を削除。
                    </t>
                    <t>
                        SETTINGS_HEADER_TABLE_SIZE 更新後のテーブルサイズの
                        最大値の通知に関する解説の追加。
                    </t>
                    <t>
                        セキュリティの懸念点の書き換え。
                    </t>
                    <t>
                        多くの編集上の解説と改良。
                    </t>
                    <t>
                        表記の節の追加。
                    </t>
                    <t>
                        ドキュメントのアウトラインの改訂。
                    </t>
                    <t>
                        静的テーブルの更新。エントリ 16 は値に "gzip, deflate"
                        を持つようにする。
                    </t>
                    <t>
                        Google から提供されたデータセットを元にハフマンテーブルを
                        更新。
                    </t>
                </list></t>
            </section>
            <section title="draft-ietf-httpbis-header-compression-06 からの変更点"
                anchor="changes.since.draft-ietf-httpbis-header-compression-06">
                <t><list style="symbols">
                    <t>
                        圧縮されてはいけないリテラルヘッダを含むフォーマットの更新。
                    </t>
                    <t>
                        セキュリティの懸念点の更新。
                    </t>
                    <t>
                        整数エンコーディングの例を付録に移動。
                    </t>
                    <t>
                        ハフマンテーブルの更新。
                    </t>
                    <t>
                        静的ヘッダテーブルの更新 (ステータス値の追加と削除) 。
                    </t>
                    <t>
                        例の更新。
                    </t>
                </list></t>
            </section>
            <section title="draft-ietf-httpbis-header-compression-05 からの変更点"
                anchor="changes.since.draft-ietf-httpbis-header-compression-05">
                <t><list style="symbols">
                    <t>
                        例を刷新。
                    </t>
                    <t>
                        リクエストとレスポンスのハフマンテーブルを一つのみにした。
                    </t>
                    <t>
                        SETTINGS_HEADER_TABLE_SIZE と独立した動的テーブルサイズの
                        最大値を追加。
                    </t>
                    <t>
                        整数デコードの擬似コードを追加。
                    </t>
                    <t>
                        例の改良 (不要な削除処理を除去) 。
                    </t>
                </list></t>
            </section>
            <section title="draft-ietf-httpbis-header-compression-04 からの変更点"
                anchor="changes.since.draft-ietf-httpbis-header-compression-04">
                <t><list style="symbols">
                    <t>
                        例の更新: 仕様内の変更を考慮し、更なる特徴を示す。
                    </t>
                    <t>
                        'バイト' と 'オクテット' の両方を使用する代わりにどこでも
                        'オクテット' に統一。
                    </t>
                    <t>
                        リファレンスセットを空にする挙動の追加。
                    </t>
                    <t>
                        編集上の変更と説明。
                    </t>
                    <t>
                        静的テーブルに "host" ヘッダを追加。
                    </t>
                    <t>
                        (NULL- かカンマ区切りの) 値のリストを整列。
                    </t>
                </list></t>
            </section>

            <section title="draft-ietf-httpbis-header-compression-03 からの変更点"
                anchor="changes.since.draft-ietf-httpbis-header-compression-03">
                <t><list style="symbols">
                    <t>
                        大量の編集上の変更; 新しいエントリの削除 / 追加の説明を
                        変更。
                    </t>
                    <t>
                        代理インデクシングを削除。
                    </t>
                    <t>
                        issue #258 に従い、初期ヘッダを静的ヘッダに変更。
                    </t>
                    <t>
                        issue #259 に従い、静的ヘッダの 'リクエスト' と
                        'レスポンス' を合併。
                    </t>
                    <t>
                        issue #233 に従い、インデックス 0 に追加される新しい
                        ヘッダを指定し、巨大なインデックスから失効する文章を
                        変更。
                    </t>
                </list></t>
            </section>
            <section title="draft-ietf-httpbis-header-compression-02 からの変更点">
                <t><list style="symbols">
                    <t>
                        整数エンコーディングの擬似コードのエラーを修正。
                    </t>
                </list></t>
            </section>

            <section title="draft-ietf-httpbis-header-compression-01 からの変更点">
                <t>
                    <list style="symbols">
                        <t>
                            ヘッダエンコーディングの節のリファクタリング:
                            定義と処理規則の分離。
                        </t>
                        <t>
                            後方互換性の無い変更: issue #214 に従いリファレンス
                            セット管理を更新。これはリファレンスセットと削除動作の
                            間の作用の仕方を変更します。また、幾つかの特定ケースに
                            おけるリファレンスセットの動作も変更します。
                        </t>
                        <t>
                            後方互換性の無い変更: issue #188 に従い、初期
                            ヘッダリストを修正。
                        </t>
                        <t>
                            32 オクテットエントリ構造の例を追加 (issue #191) 。
                        </t>
                        <t>
                            ヘッダセットの完全な節を追加。幾つかの文章の再追加。
                            得られた幾つかの記述の明確化。重複したヘッダエントリ
                            のエンコーディングに関する文章を追加。ヘッダセットに
                            関する幾つかの言語の明確化。アプリケーションが
                            より素早くメモリを解放できるようにする内容を含む
                            ヘッダ削除の節の文章を追加。セキュリティの懸念点の節
                            の情報を追加。
                        </t>
                    </list>
                </t>
            </section>
            <section title="draft-ietf-httpbis-header-compression-00 からの変更点">
                <t>
                    <list>
                        <t>整数表現アルゴリズムにおけるバグと欠点の修正。</t>
                        <t>文書タイトルの変更。</t>
                        <t>ヘッダマッチングの解説の書き換え。</t>
                        <t>ヘッダ排出の定義の変更。</t>
                        <t>圧縮コンテキストがどのくらいメモリを使うべきかに影響する
                        設定名の変更。</t>
                        <t>"特定のユースケース" 節の削除</t>
                        <t>インデックスが一つのオクテット内に含むことができることに
                        関する不正確な記述を修正</t>
                        <t>演算コードの説明を追加</t>
                        <t>導入からセキュリティクレームを削除</t>
                    </list>
                </t>
            </section>
        </section>

    </back>
</rfc>
<!--
  vim:et:tw=80:sw=4:
 -->
